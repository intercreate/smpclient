{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simple Management Protocol (SMP) Client","text":"<p>Simple Management Protocol (SMP) Client.</p> <p>This package implements transport layers for the Simple Management Protocol (SMP). The SMP Protocol defines common management operations for MCUs like firmware updates, file management, configuration, and statistics retrieval.</p> <p>Additionally, SMP is extensible, allowing for custom commands to be defined to meet the specific needs of the product.</p>"},{"location":"#smpclient--operating-systems","title":"Operating Systems","text":"Windows 11 Ubuntu macOS (Arm/x86) Serial (UART, USB, CAN, ...) \u2705 \u2705 \u2705 Bluetooth Low Energy (BLE) \u2705 \u2705 \u2705 UDP (Ethernet, Wi-Fi) \u2705 \u2705 \u2705"},{"location":"#smpclient--examples","title":"Examples","text":"<p>Many usage examples are available on GitHub or in your local clone at <code>examples/</code>.</p>"},{"location":"#smpclient.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"#smpclient.SMPClient","title":"<code>SMPClient</code>","text":"<p>Create a client to the SMP server <code>address</code>, using <code>transport</code>.</p> <p>This class provides a high-level interface to an SMP server.  Other than the <code>request</code> method, all methods are abstractions of common SMP routines, such as uploading a FW image or downloading a file.</p> <p>The <code>request</code> method is used to send an SMP request to the server and return the response or error.</p> <p>Parameters:</p> Name Type Description Default <code>transport</code> <code>SMPTransport</code> <p>the <code>SMPTransport</code> to use</p> required <code>address</code> <code>str</code> <p>the address of the SMP server, see <code>smpclient.transport</code> for details</p> required <pre><code>import asyncio\nfrom smpclient import SMPClient\nfrom smpclient.requests.os_management import EchoWrite\nfrom smpclient.transport.ble import SMPBLETransport\n\nasync def main():\n    async with SMPClient(SMPBLETransport(), \"00:11:22:33:44:55\") as client:\n        response = await client.request(EchoWrite(d=\"Hello, World!\"))\n\n        if success(response):\n            print(f\"Response: {response=}\")\n        elif error(response):\n            print(f\"Error: {response=}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> Source code in <code>smpclient/__init__.py</code> <pre><code>class SMPClient:\n    \"\"\"Create a client to the SMP server `address`, using `transport`.\n\n    This class provides a high-level interface to an SMP server.  Other than\n    the `request` method, all methods are abstractions of common SMP routines,\n    such as uploading a FW image or downloading a file.\n\n    The `request` method is used to send an SMP request to the server and return\n    the response or error.\n\n    Args:\n        transport: the `SMPTransport` to use\n        address: the address of the SMP server, see `smpclient.transport` for details\n\n    Example:\n\n    ```python\n    import asyncio\n    from smpclient import SMPClient\n    from smpclient.requests.os_management import EchoWrite\n    from smpclient.transport.ble import SMPBLETransport\n\n    async def main():\n        async with SMPClient(SMPBLETransport(), \"00:11:22:33:44:55\") as client:\n            response = await client.request(EchoWrite(d=\"Hello, World!\"))\n\n            if success(response):\n                print(f\"Response: {response=}\")\n            elif error(response):\n                print(f\"Error: {response=}\")\n\n    if __name__ == \"__main__\":\n        asyncio.run(main())\n    ```\n    \"\"\"\n\n    def __init__(self, transport: SMPTransport, address: str):  # noqa: DOC301\n        self._transport: Final = transport\n        self._address: Final = address\n\n    async def connect(self, timeout_s: float = 5.0) -&gt; None:\n        \"\"\"Connect to the SMP server.\n\n        Args:\n            timeout_s: the timeout for the connection attempt in seconds\n        \"\"\"\n        await self._transport.connect(self._address, timeout_s)\n        await self._initialize()\n\n    async def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from the SMP server.\"\"\"\n        await self._transport.disconnect()\n\n    async def request(\n        self, request: SMPRequest[TRep, TEr1, TEr2], timeout_s: float = 120.000\n    ) -&gt; TRep | TEr1 | TEr2:\n        \"\"\"Make an `SMPRequest` to the SMP server and return the Response or Error.\n\n        Args:\n            request: the `SMPRequest` to send\n            timeout_s: the timeout for the request in seconds\n\n        Returns:\n            The typed and validated Response or Error\n\n        Raises:\n            TimeoutError: if the request times out\n            SMPBadSequence: if the response sequence does not match the request sequence\n            ValidationError: if the response cannot be parsed as a Response or Error\n\n        Examples:\n\n        Usage:\n\n        ```python\n        response = await client.request(EchoWrite(d=\"Hello, World!\"))\n        if success(response):\n            print(f\"Response: {response=}\")\n        elif error(response):\n            print(f\"Error: {response=}\")\n        ```\n\n        Type Safety with Generic Typing:\n\n        ```python\n        response = await client.request(EchoWrite(d=\"Hello, World!\"))\n        reveal_type(response)\n        # Revealed type is 'Union[EchoWriteResponse, EchoWriteErrorV1, EchoWriteErrorV2]'\n        if success(response):\n            reveal_type(response)\n            # Revealed type is 'EchoWriteResponse'\n        elif error(response):\n            reveal_type(response)\n            # Revealed type is 'Union[EchoWriteErrorV1, EchoWriteErrorV2]'\n            if error_v1(response):\n                reveal_type(response)\n                # Revealed type is 'EchoWriteErrorV1'\n            else:\n                reveal_type(response)\n                # Revealed type is 'EchoWriteErrorV2'\n        ```\n\n        \"\"\"\n\n        try:\n            async with timeout(timeout_s):\n                frame = await self._transport.send_and_receive(request.BYTES)\n        except asyncio.TimeoutError:\n            timeout_message: Final = f\"Timeout ({timeout_s}s) waiting for request {request}\"\n            logger.error(timeout_message)\n            raise TimeoutError(timeout_message)\n\n        header = smpheader.Header.loads(frame[: smpheader.Header.SIZE])\n\n        if header.sequence != request.header.sequence:\n            raise SMPBadSequence(\n                f\"Bad sequence {header.sequence}, expected {request.header.sequence}\"\n            )\n\n        try:\n            return request._Response.loads(frame)  # type: ignore\n        except ValidationError:\n            pass\n        try:\n            return request._ErrorV1.loads(frame)\n        except ValidationError:\n            pass\n        try:\n            return request._ErrorV2.loads(frame)\n        except ValidationError:\n            error_message = (\n                f\"Response could not by parsed as one of {request._Response}, \"\n                f\"{request._ErrorV1}, or {request._ErrorV2}. {header=} {frame=}\"\n            )\n            logger.error(error_message)\n            raise ValidationError(error_message)\n\n    async def upload(\n        self,\n        image: bytes,\n        slot: int = 0,\n        upgrade: bool = False,\n        first_timeout_s: float = 40.000,\n        subsequent_timeout_s: float = 2.500,\n        use_sha: bool = True,\n    ) -&gt; AsyncIterator[int]:\n        \"\"\"Iteratively upload an `image` to `slot`, yielding the offset.\n\n        Args:\n            image: the `bytes` to upload\n            slot: the slot to upload to (0 for default)\n            upgrade: `True` to mark the image as confirmed.  This is unsafe and\n                can cause a boot-loop that could brick the device.  This setting\n                should be left at the default `False` and the image should be\n                confirmed from within the upgraded application.  Zephyr provides\n                [boot_write_img_confirmed()](https://docs.zephyrproject.org/apidoc/latest/group__mcuboot__api.html#ga95ccc9e1c7460fec16b9ce9ac8ad7a72)\n                for this purpose.\n            first_timeout_s: the timeout for the first `ImageUploadWrite` request\n            subsequent_timeout_s: the timeout for subsequent `ImageUploadWrite` requests\n            use_sha: `True` to include the SHA256 hash of the image in the first\n                packet.\n\n                Zephyr's SMP server will fail with `MGMT_ERR.EINVAL` if the\n                MTU is too small to include both the SHA256 and the first 32-bytes\n                of the image.  Increase the MTU or set `use_sha=False` in this case.\n\n        Yields:\n            the offset of the image upload\n\n        Raises:\n            SMPUploadError: if the upload routine fails\n        \"\"\"\n\n        response = await self.request(\n            self._maximize_image_upload_write_packet(\n                ImageUploadWrite(\n                    off=0,\n                    data=b\"\",\n                    image=slot,\n                    len=len(image),\n                    sha=sha256(image).digest() if use_sha else None,\n                    upgrade=upgrade,\n                ),\n                image,\n            ),\n            timeout_s=first_timeout_s,\n        )\n\n        if error(response):\n            raise SMPUploadError(response)\n        elif success(response):\n            if response.off is None:\n                raise SMPUploadError(f\"No offset received: {response=}\")\n            yield response.off\n        else:  # pragma: no cover\n            _unreachable()\n\n        # send chunks until the SMP server reports that the offset is at the end of the image\n        while response.off != len(image):\n            response = await self.request(\n                self._maximize_image_upload_write_packet(\n                    ImageUploadWrite(\n                        off=response.off,\n                        data=b\"\",\n                        len=len(image) if response.off == 0 else None,\n                        image=slot if response.off == 0 else None,\n                        upgrade=upgrade if response.off == 0 else None,\n                    ),\n                    image,\n                ),\n                timeout_s=subsequent_timeout_s,\n            )\n            if error(response):\n                raise SMPUploadError(response)\n            elif success(response):\n                if response.off is None:\n                    raise SMPUploadError(f\"No offset received: {response=}\")\n                yield response.off\n            else:  # pragma: no cover\n                _unreachable()\n\n        logger.info(\"Upload complete\")\n\n        if response.match is not None:\n            logger.info(f\"Server reports {response.match=}\")\n            if response.match is not True:\n                message: Final = f\"Upload failed, server reported mismatched SHA256: {response}\"\n                logger.error(message)\n                raise SMPUploadError(message)\n\n    async def upload_file(\n        self,\n        file_data: bytes,\n        file_path: str,\n        timeout_s: float = 2.500,\n    ) -&gt; AsyncIterator[int]:\n        \"\"\"Iteratively upload a `file_data` to `file_path`, yielding the offset.\n\n        Args:\n            file_data: the `bytes` to upload\n            file_path: the path to upload to\n            timeout_s: the timeout for each `FileUpload` request\n\n        Yields:\n            int: the offset of the file upload\n\n        Raises:\n            SMPUploadError: if the upload routine fails\n        \"\"\"\n        response = await self.request(\n            self._maximize_file_upload_packet(\n                FileUpload(name=file_path, off=0, data=b\"\", len=len(file_data)),\n                file_data,\n            ),\n            timeout_s=timeout_s,\n        )\n\n        if error(response):\n            raise SMPUploadError(response)\n        elif success(response):\n            if response.off is None:\n                raise SMPUploadError(f\"No offset received: {response=}\")\n            yield response.off\n        else:  # pragma: no cover\n            _unreachable()\n\n        # send chunks until the SMP server reports that the offset is at the end of the image\n        while response.off != len(file_data):\n            response = await self.request(\n                self._maximize_file_upload_packet(\n                    FileUpload(name=file_path, off=response.off, data=b\"\"), file_data\n                ),\n                timeout_s=timeout_s,\n            )\n            if error(response):\n                raise SMPUploadError(response)\n            elif success(response):\n                yield response.off\n            else:  # pragma: no cover\n                _unreachable()\n\n        logger.info(\"Upload complete\")\n\n    async def download_file(\n        self,\n        file_path: str,\n        timeout_s: float = 2.500,\n    ) -&gt; bytes:\n        \"\"\"Download a file from the SMP server.\n\n        Args:\n            file_path: the path to download\n            timeout_s: the timeout for each `FileDownload` request\n\n        Returns:\n            The downloaded file as `bytes`\n\n        Raises:\n            SMPUploadError: if the download routine fails\n        \"\"\"\n        response = await self.request(FileDownload(off=0, name=file_path), timeout_s=timeout_s)\n        file_length = 0\n\n        if error(response):\n            raise SMPUploadError(response)\n        elif success(response):\n            if response.len is None:\n                raise SMPUploadError(f\"No length received: {response=}\")\n            file_length = response.len\n        else:  # pragma: no cover\n            _unreachable()\n\n        file_data = response.data\n\n        # send chunks until the SMP server reports that the offset is at the end of the image\n        while response.off + len(response.data) != file_length:\n            response = await self.request(\n                FileDownload(off=response.off + len(response.data), name=file_path),\n                timeout_s=timeout_s,\n            )\n            if error(response):\n                raise SMPUploadError(response)\n            elif success(response):\n                file_data += response.data\n            else:  # pragma: no cover\n                _unreachable()\n\n        logger.info(\"Download complete\")\n        return file_data\n\n    @property\n    def address(self) -&gt; str:\n        \"\"\"The SMP server address.\"\"\"\n\n        return self._address\n\n    async def __aenter__(self) -&gt; \"SMPClient\":\n        await self.connect()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        if exc_value is not None:\n            logger.error(f\"Exception in SMPClient: {exc_type=}, {exc_value=}, {traceback=}\")\n        await self.disconnect()\n\n    @staticmethod\n    def _cbor_integer_size(integer: int) -&gt; int:\n        \"\"\"CBOR integers are packed as small as possible.\"\"\"\n\n        # If the integer is less than 24, then the size is encoded in the same\n        # byte as the value.\n        # https://datatracker.ietf.org/doc/html/rfc8949#name-core-deterministic-encoding\n        return 0 if integer &lt; 24 else 1 if integer &lt; 0xFF else 2 if integer &lt; 0xFFFF else 4\n\n    def _get_max_cbor_and_data_size(self, request: smpmsg.WriteRequest) -&gt; Tuple[int, int]:\n        \"\"\"Given an `ImageUploadWrite`, return the maximum CBOR size and data size.\"\"\"\n\n        # given empty data in the request, how many bytes are available for the data?\n        unencoded_bytes_available: Final = self._transport.max_unencoded_size - len(bytes(request))\n\n        # how many bytes are required to encode the data size?\n        bytes_required_to_encode_data_size: Final = self._cbor_integer_size(\n            unencoded_bytes_available\n        )\n\n        # the final data size is the unencoded bytes available minus the bytes\n        # required to encode the data size\n        data_size: Final = max(0, unencoded_bytes_available - bytes_required_to_encode_data_size)\n        # the final CBOR size is the original header length plus the data size\n        # plus the bytes required to encode the data size\n        cbor_size: Final = request.header.length + data_size + self._cbor_integer_size(data_size)\n\n        return cbor_size, data_size\n\n    def _maximize_image_upload_write_packet(\n        self, request: ImageUploadWrite, image: bytes\n    ) -&gt; ImageUploadWrite:\n        \"\"\"Given an `ImageUploadWrite` with empty `data`, return the largest packet possible.\"\"\"\n\n        h: Final = request.header\n        cbor_size, data_size = self._get_max_cbor_and_data_size(request)\n\n        if data_size &gt; len(image) - request.off:  # final packet\n            data_size = len(image) - request.off\n            cbor_size = h.length + data_size + self._cbor_integer_size(data_size)\n\n        return ImageUploadWrite(\n            header=smpheader.Header(\n                op=h.op,\n                version=h.version,\n                flags=h.flags,\n                length=cbor_size,\n                group_id=h.group_id,\n                sequence=h.sequence,\n                command_id=h.command_id,\n            ),\n            off=request.off,\n            data=image[request.off : request.off + data_size],\n            image=request.image,\n            len=request.len,\n            sha=request.sha,\n            upgrade=request.upgrade,\n        )\n\n    def _maximize_file_upload_packet(self, request: FileUpload, data: bytes) -&gt; FileUpload:\n        \"\"\"Given an `FileUpload` with empty `data`, return the largest packet possible.\"\"\"\n        h: Final = request.header\n        cbor_size, data_size = self._get_max_cbor_and_data_size(request)\n        if data_size &gt; len(data) - request.off:  # final packet\n            data_size = len(data) - request.off\n            cbor_size = h.length + data_size + self._cbor_integer_size(data_size)\n        return FileUpload(\n            header=smpheader.Header(\n                op=h.op,\n                version=h.version,\n                flags=h.flags,\n                length=cbor_size,\n                group_id=h.group_id,\n                sequence=h.sequence,\n                command_id=h.command_id,\n            ),\n            name=request.name,\n            off=request.off,\n            data=data[request.off : request.off + data_size],\n            len=request.len,\n        )\n\n    async def _initialize(self) -&gt; None:\n        \"\"\"Gather initialization information from the SMP server.\"\"\"\n\n        try:\n            async with timeout(2):\n                mcumgr_parameters = await self.request(MCUMgrParametersRead())\n                if success(mcumgr_parameters):\n                    logger.debug(f\"MCUMgr parameters: {mcumgr_parameters}\")\n                    self._transport.initialize(mcumgr_parameters.buf_size)\n                elif error(mcumgr_parameters):\n                    logger.warning(f\"Error reading MCUMgr parameters: {mcumgr_parameters}\")\n                else:\n                    _unreachable()\n        except asyncio.TimeoutError:\n            logger.warning(\"Timeout waiting for MCUMgr parameters\")\n</code></pre>"},{"location":"#smpclient.SMPClient.address","title":"<code>address: str</code>  <code>property</code>","text":"<p>The SMP server address.</p>"},{"location":"#smpclient.SMPClient.__init__","title":"<code>__init__(transport: SMPTransport, address: str)</code>","text":"Source code in <code>smpclient/__init__.py</code> <pre><code>def __init__(self, transport: SMPTransport, address: str):  # noqa: DOC301\n    self._transport: Final = transport\n    self._address: Final = address\n</code></pre>"},{"location":"#smpclient.SMPClient.connect","title":"<code>connect(timeout_s: float = 5.0) -&gt; None</code>  <code>async</code>","text":"<p>Connect to the SMP server.</p> <p>Parameters:</p> Name Type Description Default <code>timeout_s</code> <code>float</code> <p>the timeout for the connection attempt in seconds</p> <code>5.0</code> Source code in <code>smpclient/__init__.py</code> <pre><code>async def connect(self, timeout_s: float = 5.0) -&gt; None:\n    \"\"\"Connect to the SMP server.\n\n    Args:\n        timeout_s: the timeout for the connection attempt in seconds\n    \"\"\"\n    await self._transport.connect(self._address, timeout_s)\n    await self._initialize()\n</code></pre>"},{"location":"#smpclient.SMPClient.disconnect","title":"<code>disconnect() -&gt; None</code>  <code>async</code>","text":"<p>Disconnect from the SMP server.</p> Source code in <code>smpclient/__init__.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from the SMP server.\"\"\"\n    await self._transport.disconnect()\n</code></pre>"},{"location":"#smpclient.SMPClient.request","title":"<code>request(request: SMPRequest[TRep, TEr1, TEr2], timeout_s: float = 120.0) -&gt; TRep | TEr1 | TEr2</code>  <code>async</code>","text":"<p>Make an <code>SMPRequest</code> to the SMP server and return the Response or Error.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>SMPRequest[TRep, TEr1, TEr2]</code> <p>the <code>SMPRequest</code> to send</p> required <code>timeout_s</code> <code>float</code> <p>the timeout for the request in seconds</p> <code>120.0</code> <p>Returns:</p> Type Description <code>TRep | TEr1 | TEr2</code> <p>The typed and validated Response or Error</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>if the request times out</p> <code>SMPBadSequence</code> <p>if the response sequence does not match the request sequence</p> <code>ValidationError</code> <p>if the response cannot be parsed as a Response or Error</p> <p>Usage:</p> <pre><code>response = await client.request(EchoWrite(d=\"Hello, World!\"))\nif success(response):\n    print(f\"Response: {response=}\")\nelif error(response):\n    print(f\"Error: {response=}\")\n</code></pre> <p>Type Safety with Generic Typing:</p> <pre><code>response = await client.request(EchoWrite(d=\"Hello, World!\"))\nreveal_type(response)\n# Revealed type is 'Union[EchoWriteResponse, EchoWriteErrorV1, EchoWriteErrorV2]'\nif success(response):\n    reveal_type(response)\n    # Revealed type is 'EchoWriteResponse'\nelif error(response):\n    reveal_type(response)\n    # Revealed type is 'Union[EchoWriteErrorV1, EchoWriteErrorV2]'\n    if error_v1(response):\n        reveal_type(response)\n        # Revealed type is 'EchoWriteErrorV1'\n    else:\n        reveal_type(response)\n        # Revealed type is 'EchoWriteErrorV2'\n</code></pre> Source code in <code>smpclient/__init__.py</code> <pre><code>async def request(\n    self, request: SMPRequest[TRep, TEr1, TEr2], timeout_s: float = 120.000\n) -&gt; TRep | TEr1 | TEr2:\n    \"\"\"Make an `SMPRequest` to the SMP server and return the Response or Error.\n\n    Args:\n        request: the `SMPRequest` to send\n        timeout_s: the timeout for the request in seconds\n\n    Returns:\n        The typed and validated Response or Error\n\n    Raises:\n        TimeoutError: if the request times out\n        SMPBadSequence: if the response sequence does not match the request sequence\n        ValidationError: if the response cannot be parsed as a Response or Error\n\n    Examples:\n\n    Usage:\n\n    ```python\n    response = await client.request(EchoWrite(d=\"Hello, World!\"))\n    if success(response):\n        print(f\"Response: {response=}\")\n    elif error(response):\n        print(f\"Error: {response=}\")\n    ```\n\n    Type Safety with Generic Typing:\n\n    ```python\n    response = await client.request(EchoWrite(d=\"Hello, World!\"))\n    reveal_type(response)\n    # Revealed type is 'Union[EchoWriteResponse, EchoWriteErrorV1, EchoWriteErrorV2]'\n    if success(response):\n        reveal_type(response)\n        # Revealed type is 'EchoWriteResponse'\n    elif error(response):\n        reveal_type(response)\n        # Revealed type is 'Union[EchoWriteErrorV1, EchoWriteErrorV2]'\n        if error_v1(response):\n            reveal_type(response)\n            # Revealed type is 'EchoWriteErrorV1'\n        else:\n            reveal_type(response)\n            # Revealed type is 'EchoWriteErrorV2'\n    ```\n\n    \"\"\"\n\n    try:\n        async with timeout(timeout_s):\n            frame = await self._transport.send_and_receive(request.BYTES)\n    except asyncio.TimeoutError:\n        timeout_message: Final = f\"Timeout ({timeout_s}s) waiting for request {request}\"\n        logger.error(timeout_message)\n        raise TimeoutError(timeout_message)\n\n    header = smpheader.Header.loads(frame[: smpheader.Header.SIZE])\n\n    if header.sequence != request.header.sequence:\n        raise SMPBadSequence(\n            f\"Bad sequence {header.sequence}, expected {request.header.sequence}\"\n        )\n\n    try:\n        return request._Response.loads(frame)  # type: ignore\n    except ValidationError:\n        pass\n    try:\n        return request._ErrorV1.loads(frame)\n    except ValidationError:\n        pass\n    try:\n        return request._ErrorV2.loads(frame)\n    except ValidationError:\n        error_message = (\n            f\"Response could not by parsed as one of {request._Response}, \"\n            f\"{request._ErrorV1}, or {request._ErrorV2}. {header=} {frame=}\"\n        )\n        logger.error(error_message)\n        raise ValidationError(error_message)\n</code></pre>"},{"location":"#smpclient.SMPClient.upload","title":"<code>upload(image: bytes, slot: int = 0, upgrade: bool = False, first_timeout_s: float = 40.0, subsequent_timeout_s: float = 2.5, use_sha: bool = True) -&gt; AsyncIterator[int]</code>  <code>async</code>","text":"<p>Iteratively upload an <code>image</code> to <code>slot</code>, yielding the offset.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>bytes</code> <p>the <code>bytes</code> to upload</p> required <code>slot</code> <code>int</code> <p>the slot to upload to (0 for default)</p> <code>0</code> <code>upgrade</code> <code>bool</code> <p><code>True</code> to mark the image as confirmed.  This is unsafe and can cause a boot-loop that could brick the device.  This setting should be left at the default <code>False</code> and the image should be confirmed from within the upgraded application.  Zephyr provides boot_write_img_confirmed() for this purpose.</p> <code>False</code> <code>first_timeout_s</code> <code>float</code> <p>the timeout for the first <code>ImageUploadWrite</code> request</p> <code>40.0</code> <code>subsequent_timeout_s</code> <code>float</code> <p>the timeout for subsequent <code>ImageUploadWrite</code> requests</p> <code>2.5</code> <code>use_sha</code> <code>bool</code> <p><code>True</code> to include the SHA256 hash of the image in the first packet.</p> <p>Zephyr's SMP server will fail with <code>MGMT_ERR.EINVAL</code> if the MTU is too small to include both the SHA256 and the first 32-bytes of the image.  Increase the MTU or set <code>use_sha=False</code> in this case.</p> <code>True</code> <p>Yields:</p> Type Description <code>AsyncIterator[int]</code> <p>the offset of the image upload</p> <p>Raises:</p> Type Description <code>SMPUploadError</code> <p>if the upload routine fails</p> Source code in <code>smpclient/__init__.py</code> <pre><code>async def upload(\n    self,\n    image: bytes,\n    slot: int = 0,\n    upgrade: bool = False,\n    first_timeout_s: float = 40.000,\n    subsequent_timeout_s: float = 2.500,\n    use_sha: bool = True,\n) -&gt; AsyncIterator[int]:\n    \"\"\"Iteratively upload an `image` to `slot`, yielding the offset.\n\n    Args:\n        image: the `bytes` to upload\n        slot: the slot to upload to (0 for default)\n        upgrade: `True` to mark the image as confirmed.  This is unsafe and\n            can cause a boot-loop that could brick the device.  This setting\n            should be left at the default `False` and the image should be\n            confirmed from within the upgraded application.  Zephyr provides\n            [boot_write_img_confirmed()](https://docs.zephyrproject.org/apidoc/latest/group__mcuboot__api.html#ga95ccc9e1c7460fec16b9ce9ac8ad7a72)\n            for this purpose.\n        first_timeout_s: the timeout for the first `ImageUploadWrite` request\n        subsequent_timeout_s: the timeout for subsequent `ImageUploadWrite` requests\n        use_sha: `True` to include the SHA256 hash of the image in the first\n            packet.\n\n            Zephyr's SMP server will fail with `MGMT_ERR.EINVAL` if the\n            MTU is too small to include both the SHA256 and the first 32-bytes\n            of the image.  Increase the MTU or set `use_sha=False` in this case.\n\n    Yields:\n        the offset of the image upload\n\n    Raises:\n        SMPUploadError: if the upload routine fails\n    \"\"\"\n\n    response = await self.request(\n        self._maximize_image_upload_write_packet(\n            ImageUploadWrite(\n                off=0,\n                data=b\"\",\n                image=slot,\n                len=len(image),\n                sha=sha256(image).digest() if use_sha else None,\n                upgrade=upgrade,\n            ),\n            image,\n        ),\n        timeout_s=first_timeout_s,\n    )\n\n    if error(response):\n        raise SMPUploadError(response)\n    elif success(response):\n        if response.off is None:\n            raise SMPUploadError(f\"No offset received: {response=}\")\n        yield response.off\n    else:  # pragma: no cover\n        _unreachable()\n\n    # send chunks until the SMP server reports that the offset is at the end of the image\n    while response.off != len(image):\n        response = await self.request(\n            self._maximize_image_upload_write_packet(\n                ImageUploadWrite(\n                    off=response.off,\n                    data=b\"\",\n                    len=len(image) if response.off == 0 else None,\n                    image=slot if response.off == 0 else None,\n                    upgrade=upgrade if response.off == 0 else None,\n                ),\n                image,\n            ),\n            timeout_s=subsequent_timeout_s,\n        )\n        if error(response):\n            raise SMPUploadError(response)\n        elif success(response):\n            if response.off is None:\n                raise SMPUploadError(f\"No offset received: {response=}\")\n            yield response.off\n        else:  # pragma: no cover\n            _unreachable()\n\n    logger.info(\"Upload complete\")\n\n    if response.match is not None:\n        logger.info(f\"Server reports {response.match=}\")\n        if response.match is not True:\n            message: Final = f\"Upload failed, server reported mismatched SHA256: {response}\"\n            logger.error(message)\n            raise SMPUploadError(message)\n</code></pre>"},{"location":"#smpclient.SMPClient.upload_file","title":"<code>upload_file(file_data: bytes, file_path: str, timeout_s: float = 2.5) -&gt; AsyncIterator[int]</code>  <code>async</code>","text":"<p>Iteratively upload a <code>file_data</code> to <code>file_path</code>, yielding the offset.</p> <p>Parameters:</p> Name Type Description Default <code>file_data</code> <code>bytes</code> <p>the <code>bytes</code> to upload</p> required <code>file_path</code> <code>str</code> <p>the path to upload to</p> required <code>timeout_s</code> <code>float</code> <p>the timeout for each <code>FileUpload</code> request</p> <code>2.5</code> <p>Yields:</p> Name Type Description <code>int</code> <code>AsyncIterator[int]</code> <p>the offset of the file upload</p> <p>Raises:</p> Type Description <code>SMPUploadError</code> <p>if the upload routine fails</p> Source code in <code>smpclient/__init__.py</code> <pre><code>async def upload_file(\n    self,\n    file_data: bytes,\n    file_path: str,\n    timeout_s: float = 2.500,\n) -&gt; AsyncIterator[int]:\n    \"\"\"Iteratively upload a `file_data` to `file_path`, yielding the offset.\n\n    Args:\n        file_data: the `bytes` to upload\n        file_path: the path to upload to\n        timeout_s: the timeout for each `FileUpload` request\n\n    Yields:\n        int: the offset of the file upload\n\n    Raises:\n        SMPUploadError: if the upload routine fails\n    \"\"\"\n    response = await self.request(\n        self._maximize_file_upload_packet(\n            FileUpload(name=file_path, off=0, data=b\"\", len=len(file_data)),\n            file_data,\n        ),\n        timeout_s=timeout_s,\n    )\n\n    if error(response):\n        raise SMPUploadError(response)\n    elif success(response):\n        if response.off is None:\n            raise SMPUploadError(f\"No offset received: {response=}\")\n        yield response.off\n    else:  # pragma: no cover\n        _unreachable()\n\n    # send chunks until the SMP server reports that the offset is at the end of the image\n    while response.off != len(file_data):\n        response = await self.request(\n            self._maximize_file_upload_packet(\n                FileUpload(name=file_path, off=response.off, data=b\"\"), file_data\n            ),\n            timeout_s=timeout_s,\n        )\n        if error(response):\n            raise SMPUploadError(response)\n        elif success(response):\n            yield response.off\n        else:  # pragma: no cover\n            _unreachable()\n\n    logger.info(\"Upload complete\")\n</code></pre>"},{"location":"#smpclient.SMPClient.download_file","title":"<code>download_file(file_path: str, timeout_s: float = 2.5) -&gt; bytes</code>  <code>async</code>","text":"<p>Download a file from the SMP server.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the path to download</p> required <code>timeout_s</code> <code>float</code> <p>the timeout for each <code>FileDownload</code> request</p> <code>2.5</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The downloaded file as <code>bytes</code></p> <p>Raises:</p> Type Description <code>SMPUploadError</code> <p>if the download routine fails</p> Source code in <code>smpclient/__init__.py</code> <pre><code>async def download_file(\n    self,\n    file_path: str,\n    timeout_s: float = 2.500,\n) -&gt; bytes:\n    \"\"\"Download a file from the SMP server.\n\n    Args:\n        file_path: the path to download\n        timeout_s: the timeout for each `FileDownload` request\n\n    Returns:\n        The downloaded file as `bytes`\n\n    Raises:\n        SMPUploadError: if the download routine fails\n    \"\"\"\n    response = await self.request(FileDownload(off=0, name=file_path), timeout_s=timeout_s)\n    file_length = 0\n\n    if error(response):\n        raise SMPUploadError(response)\n    elif success(response):\n        if response.len is None:\n            raise SMPUploadError(f\"No length received: {response=}\")\n        file_length = response.len\n    else:  # pragma: no cover\n        _unreachable()\n\n    file_data = response.data\n\n    # send chunks until the SMP server reports that the offset is at the end of the image\n    while response.off + len(response.data) != file_length:\n        response = await self.request(\n            FileDownload(off=response.off + len(response.data), name=file_path),\n            timeout_s=timeout_s,\n        )\n        if error(response):\n            raise SMPUploadError(response)\n        elif success(response):\n            file_data += response.data\n        else:  # pragma: no cover\n            _unreachable()\n\n    logger.info(\"Download complete\")\n    return file_data\n</code></pre>"},{"location":"#smpclient.SMPClient.__aenter__","title":"<code>__aenter__() -&gt; 'SMPClient'</code>  <code>async</code>","text":"Source code in <code>smpclient/__init__.py</code> <pre><code>async def __aenter__(self) -&gt; \"SMPClient\":\n    await self.connect()\n    return self\n</code></pre>"},{"location":"#smpclient.SMPClient.__aexit__","title":"<code>__aexit__(exc_type: Type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -&gt; None</code>  <code>async</code>","text":"Source code in <code>smpclient/__init__.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None:\n    if exc_value is not None:\n        logger.error(f\"Exception in SMPClient: {exc_type=}, {exc_value=}, {traceback=}\")\n    await self.disconnect()\n</code></pre>"},{"location":"file_management/","title":"File Management","text":"<p>Refer to the smp File Management documentation for a complete description of each Request and Response.</p>"},{"location":"file_management/#smpclient.requests.file_management.FileDownload","title":"<code>FileDownload</code>","text":"<p>               Bases: <code>FileDownloadRequest</code>, <code>_FileGroupBase</code></p> <p>Download contents of an existing file from specified path.</p> <p>Client applications must keep track of data they have already downloaded and where their position in the file is, and issue subsequent requests, with modified offset, to gather the entire file.</p> <p>Request does not carry size of requested chunk, the size is specified by application itself. Note that file handles will remain open for consecutive requests (as long as an idle timeout has not been reached and another transport does not make use of uploading/downloading files using fs_mgmt), but files are not exclusively owned by SMP, for the time of download session, and may change between requests or even be removed.</p> <p>Parameters:</p> Name Type Description Default <code>off</code> <code>int</code> required <code>name</code> <code>str</code> required Source code in <code>smpclient/requests/file_management.py</code> <pre><code>class FileDownload(smpfs.FileDownloadRequest, _FileGroupBase):\n    \"\"\"Download contents of an existing file from specified path.\n\n\n    Client applications must keep track of data they have already downloaded and\n    where their position in the file is, and issue subsequent requests, with\n    modified offset, to gather the entire file.\n\n    Request does not carry size of requested chunk, the size is specified by\n    application itself. Note that file handles will remain open for consecutive\n    requests (as long as an idle timeout has not been reached and another\n    transport does not make use of uploading/downloading files using fs_mgmt),\n    but files are not exclusively owned by SMP, for the time of download\n    session, and may change between requests or even be removed.\n\n    Args:\n        off (int): \n        name (str): \n\n    \"\"\"\n    _Response = smpfs.FileDownloadResponse\n    _Response = smpfs.FileDownloadResponse\n</code></pre>"},{"location":"file_management/#smpclient.requests.file_management.FileUpload","title":"<code>FileUpload</code>","text":"<p>               Bases: <code>FileUploadRequest</code>, <code>_FileGroupBase</code></p> <p>Upload a file to a specified location.</p> <p>Command will automatically overwrite existing file or create a new one if it does not exist at specified path. The protocol supports stateless upload where each requests carries different chunk of a file and it is client side responsibility to track progress of upload.</p> <p>Note that file handles will remain open for consecutive requests (as long as an idle timeout has not been reached, but files are not exclusively owned by SMP, for the time of download session, and may change between requests or even be removed. Note that file handles will remain open for consecutive requests (as long as an idle timeout has not been reached and another transport does not make use of uploading/downloading files using fs_mgmt), but files are not exclusively owned by MCUmgr, for the time of download session, and may change between requests or even be removed.</p> <p>Parameters:</p> Name Type Description Default <code>off</code> <code>int</code> required <code>name</code> <code>str</code> required <code>len</code> <code>int | None</code> required Source code in <code>smpclient/requests/file_management.py</code> <pre><code>class FileUpload(smpfs.FileUploadRequest, _FileGroupBase):\n    \"\"\"Upload a file to a specified location.\n\n\n    Command will automatically overwrite existing file or create a new one if it\n    does not exist at specified path. The protocol supports stateless upload\n    where each requests carries different chunk of a file and it is client side\n    responsibility to track progress of upload.\n\n    Note that file handles will remain open for consecutive requests (as long as\n    an idle timeout has not been reached, but files are not exclusively owned by\n    SMP, for the time of download session, and may change between requests or\n    even be removed. Note that file handles will remain open for consecutive\n    requests (as long as an idle timeout has not been reached and another\n    transport does not make use of uploading/downloading files using fs_mgmt),\n    but files are not exclusively owned by MCUmgr, for the time of download\n    session, and may change between requests or even be removed.\n\n    Args:\n        off (int): \n        name (str): \n        len (int | None): \n\n    \"\"\"\n    _Response = smpfs.FileUploadResponse\n    _Response = smpfs.FileUploadResponse\n</code></pre>"},{"location":"file_management/#smpclient.requests.file_management.FileStatus","title":"<code>FileStatus</code>","text":"<p>               Bases: <code>FileStatusRequest</code>, <code>_FileGroupBase</code></p> <p>Retrieve status of an existing file from specified path of a target device.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required Source code in <code>smpclient/requests/file_management.py</code> <pre><code>class FileStatus(smpfs.FileStatusRequest, _FileGroupBase):\n    \"\"\"Retrieve status of an existing file from specified path of a target device.\n\n    Args:\n        name (str): \n\n    \"\"\"\n    _Response = smpfs.FileStatusResponse\n    _Response = smpfs.FileStatusResponse\n</code></pre>"},{"location":"file_management/#smpclient.requests.file_management.FileHashChecksum","title":"<code>FileHashChecksum</code>","text":"<p>               Bases: <code>FileHashChecksumRequest</code>, <code>_FileGroupBase</code></p> <p>Generate a hash/checksum of an existing file at a specified path on a target device.</p> <p>Note that kernel heap memory is required for buffers to be allocated for this to function, and large stack memory buffers are required for generation of the output hash/checksum. Requires <code>CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH</code> to be enabled for the base functionality, supported hash/checksum are opt-in with <code>CONFIG_MCUMGR_GRP_FS_CHECKSUM_IEEE_CRC32</code> or <code>CONFIG_MCUMGR_GRP_FS_HASH_SHA256</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>type</code> <code>Optional[Literal[crc32]]</code> required <code>off</code> <code>int | None</code> required <code>len</code> <code>int | None</code> required Source code in <code>smpclient/requests/file_management.py</code> <pre><code>class FileHashChecksum(smpfs.FileHashChecksumRequest, _FileGroupBase):\n    \"\"\"Generate a hash/checksum of an existing file at a specified path on a target device.\n\n\n    Note that kernel heap memory is required for buffers to be allocated for\n    this to function, and large stack memory buffers are required for generation\n    of the output hash/checksum. Requires `CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH` to\n    be enabled for the base functionality, supported hash/checksum are opt-in\n    with `CONFIG_MCUMGR_GRP_FS_CHECKSUM_IEEE_CRC32` or\n    `CONFIG_MCUMGR_GRP_FS_HASH_SHA256`.\n\n    Args:\n        name (str): \n        type (Optional[Literal[crc32]]): \n        off (int | None): \n        len (int | None): \n\n    \"\"\"\n    _Response = smpfs.FileHashChecksumResponse\n    _Response = smpfs.FileHashChecksumResponse\n</code></pre>"},{"location":"file_management/#smpclient.requests.file_management.SupportedFileHashChecksumTypes","title":"<code>SupportedFileHashChecksumTypes</code>","text":"<p>               Bases: <code>SupportedFileHashChecksumTypesRequest</code>, <code>_FileGroupBase</code></p> <p>List the hash and checksum types are available on a device.</p> <p>Requires Kconfig <code>CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH_SUPPORTED_CMD</code> to be enabled.</p> Source code in <code>smpclient/requests/file_management.py</code> <pre><code>class SupportedFileHashChecksumTypes(smpfs.SupportedFileHashChecksumTypesRequest, _FileGroupBase):\n    \"\"\"List the hash and checksum types are available on a device.\n\n\n    Requires Kconfig `CONFIG_MCUMGR_GRP_FS_CHECKSUM_HASH_SUPPORTED_CMD` to be enabled.\n\n    \"\"\"\n    _Response = smpfs.SupportedFileHashChecksumTypesResponse\n    _Response = smpfs.SupportedFileHashChecksumTypesResponse\n</code></pre>"},{"location":"file_management/#smpclient.requests.file_management.FileClose","title":"<code>FileClose</code>","text":"<p>               Bases: <code>FileCloseRequest</code>, <code>_FileGroupBase</code></p> <p>Close all open file handles held by fs_mgmt upload/download requests.</p> Source code in <code>smpclient/requests/file_management.py</code> <pre><code>class FileClose(smpfs.FileCloseRequest, _FileGroupBase):\n    \"\"\"Close all open file handles held by fs_mgmt upload/download requests.\n\n    \"\"\"\n    _Response = smpfs.FileCloseResponse\n    _Response = smpfs.FileCloseResponse\n</code></pre>"},{"location":"image_management/","title":"Image Management","text":"<p>Refer to the smp Image Management documentation for a complete description of each Request and Response.</p>"},{"location":"image_management/#smpclient.requests.image_management.ImageStatesRead","title":"<code>ImageStatesRead</code>","text":"<p>               Bases: <code>ImageStatesReadRequest</code>, <code>_ImageGroupBase</code></p> <p>Obtain list of images with their current state.</p> Source code in <code>smpclient/requests/image_management.py</code> <pre><code>class ImageStatesRead(smpimg.ImageStatesReadRequest, _ImageGroupBase):\n    \"\"\"Obtain list of images with their current state.\n\n    \"\"\"\n    _Response = smpimg.ImageStatesReadResponse\n    _Response = smpimg.ImageStatesReadResponse\n</code></pre>"},{"location":"image_management/#smpclient.requests.image_management.ImageStatesWrite","title":"<code>ImageStatesWrite</code>","text":"<p>               Bases: <code>ImageStatesWriteRequest</code>, <code>_ImageGroupBase</code></p> <p>Set the state of an image.</p> <p>If \u201cconfirm\u201d is false or not provided, an image with the \u201chash\u201d will be set for test, which means that it will not be marked as permanent and upon hard reset the previous application will be restored to the primary slot. In case when \u201cconfirm\u201d is true, the \u201chash\u201d is optional as the currently running application will be assumed as target for confirmation.</p> <p>Parameters:</p> Name Type Description Default <code>hash</code> <code>bytes | None</code> required <code>confirm</code> <code>bool</code> required Source code in <code>smpclient/requests/image_management.py</code> <pre><code>class ImageStatesWrite(smpimg.ImageStatesWriteRequest, _ImageGroupBase):\n    \"\"\"Set the state of an image.\n\n\n    If \u201cconfirm\u201d is false or not provided, an image with the \u201chash\u201d will be set\n    for test, which means that it will not be marked as permanent and upon hard\n    reset the previous application will be restored to the primary slot. In case\n    when \u201cconfirm\u201d is true, the \u201chash\u201d is optional as the currently running\n    application will be assumed as target for confirmation.\n\n    Args:\n        hash (bytes | None): \n        confirm (bool): \n\n    \"\"\"\n    _Response = smpimg.ImageStatesWriteResponse\n    _Response = smpimg.ImageStatesWriteResponse\n</code></pre>"},{"location":"image_management/#smpclient.requests.image_management.ImageUploadWrite","title":"<code>ImageUploadWrite</code>","text":"<p>               Bases: <code>ImageUploadWriteRequest</code>, <code>_ImageGroupBase</code></p> <p>Upload an image to the device.</p> <p>The image is uploaded in chunks, with each chunk being sent in a separate request. The first request must include the image's length and image number.</p> <p>Parameters:</p> Name Type Description Default <code>off</code> <code>int</code> required <code>image</code> <code>int | None</code> required <code>len</code> <code>int | None</code> required <code>sha</code> <code>bytes | None</code> required <code>upgrade</code> <code>bool | None</code> required Source code in <code>smpclient/requests/image_management.py</code> <pre><code>class ImageUploadWrite(smpimg.ImageUploadWriteRequest, _ImageGroupBase):\n    \"\"\"Upload an image to the device.\n\n\n    The image is uploaded in chunks, with each chunk being sent in a separate\n    request. The first request must include the image's length and image number.\n\n    Args:\n        off (int): \n        image (int | None): \n        len (int | None): \n        sha (bytes | None): \n        upgrade (bool | None): \n\n    \"\"\"\n    _Response = smpimg.ImageUploadWriteResponse\n    _Response = smpimg.ImageUploadWriteResponse\n</code></pre>"},{"location":"image_management/#smpclient.requests.image_management.ImageErase","title":"<code>ImageErase</code>","text":"<p>               Bases: <code>ImageEraseRequest</code>, <code>_ImageGroupBase</code></p> <p>Erase an image from a slot.</p> <p>Parameters:</p> Name Type Description Default <code>slot</code> <code>int | None</code> required Source code in <code>smpclient/requests/image_management.py</code> <pre><code>class ImageErase(smpimg.ImageEraseRequest, _ImageGroupBase):\n    \"\"\"Erase an image from a slot.\n\n    Args:\n        slot (int | None): \n\n    \"\"\"\n    _Response = smpimg.ImageEraseResponse\n    _Response = smpimg.ImageEraseResponse\n</code></pre>"},{"location":"os_management/","title":"OS Management","text":"<p>Refer to the smp OS Management documentation for a complete description of each Request and Response.</p>"},{"location":"os_management/#smpclient.requests.os_management.EchoWrite","title":"<code>EchoWrite</code>","text":"<p>               Bases: <code>EchoWriteRequest</code>, <code>_OSGroupBase</code></p> <p>Echo back the provided string.</p> Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class EchoWrite(smpos.EchoWriteRequest, _OSGroupBase):\n    \"\"\"Echo back the provided string.\n\n    \"\"\"\n    _Response = smpos.EchoWriteResponse\n    _Response = smpos.EchoWriteResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.ResetWrite","title":"<code>ResetWrite</code>","text":"<p>               Bases: <code>ResetWriteRequest</code>, <code>_OSGroupBase</code></p> <p>Performs reset of system.</p> <p>The device should issue response before resetting so that the SMP client could receive information that the command has been accepted. By default, this command is accepted in all conditions, however if the <code>CONFIG_MCUMGR_GRP_OS_RESET_HOOK</code> is enabled and an application registers a callback, the callback will be called when this command is issued and can be used to perform any necessary tidy operations prior to the module rebooting, or to reject the reset request outright altogether with an error response.</p> <p>For details on this functionality, see callbacks.  # noqa: E501</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>Optional[Literal[0]]</code> required Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class ResetWrite(smpos.ResetWriteRequest, _OSGroupBase):\n    \"\"\"Performs reset of system.\n\n\n    The device should issue response before resetting so that the SMP client\n    could receive information that the command has been accepted. By default,\n    this command is accepted in all conditions, however if the\n    `CONFIG_MCUMGR_GRP_OS_RESET_HOOK` is enabled and an application registers a\n    callback, the callback will be called when this command is issued and can be\n    used to perform any necessary tidy operations prior to the module rebooting,\n    or to reject the reset request outright altogether with an error response.\n\n    For details on this functionality, see [callbacks](https://docs.zephyrproject.org/latest/services/device_mgmt/mcumgr_callbacks.html#mcumgr-callbacks).  # noqa: E501\n\n    Args:\n        force (Optional[Literal[0]]): \n\n    \"\"\"\n    _Response = smpos.ResetWriteResponse\n    _Response = smpos.ResetWriteResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.TaskStatisticsRead","title":"<code>TaskStatisticsRead</code>","text":"<p>               Bases: <code>TaskStatisticsReadRequest</code>, <code>_OSGroupBase</code></p> <p>Request task statistics.</p> Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class TaskStatisticsRead(smpos.TaskStatisticsReadRequest, _OSGroupBase):\n    \"\"\"Request task statistics.\n\n    \"\"\"\n    _Response = smpos.TaskStatisticsReadResponse\n    _Response = smpos.TaskStatisticsReadResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.MemoryPoolStatisticsRead","title":"<code>MemoryPoolStatisticsRead</code>","text":"<p>               Bases: <code>MemoryPoolStatisticsReadRequest</code>, <code>_OSGroupBase</code></p> <p>Request memory pool statistics.</p> Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class MemoryPoolStatisticsRead(smpos.MemoryPoolStatisticsReadRequest, _OSGroupBase):\n    \"\"\"Request memory pool statistics.\n\n    \"\"\"\n    _Response = smpos.MemoryPoolStatisticsReadResponse\n    _Response = smpos.MemoryPoolStatisticsReadResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.DateTimeRead","title":"<code>DateTimeRead</code>","text":"<p>               Bases: <code>DateTimeReadRequest</code>, <code>_OSGroupBase</code></p> <p>Request the current date and time.</p> Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class DateTimeRead(smpos.DateTimeReadRequest, _OSGroupBase):\n    \"\"\"Request the current date and time.\n\n    \"\"\"\n    _Response = smpos.DateTimeReadResponse\n    _Response = smpos.DateTimeReadResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.DateTimeWrite","title":"<code>DateTimeWrite</code>","text":"<p>               Bases: <code>DateTimeWriteRequest</code>, <code>_OSGroupBase</code></p> <p>Set the current date and time.</p> <p>Parameters:</p> Name Type Description Default <code>datetime</code> <code>str</code> required Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class DateTimeWrite(smpos.DateTimeWriteRequest, _OSGroupBase):\n    \"\"\"Set the current date and time.\n\n    Args:\n        datetime (str): \n\n    \"\"\"\n    _Response = smpos.DateTimeWriteResponse\n    _Response = smpos.DateTimeWriteResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.MCUMgrParametersRead","title":"<code>MCUMgrParametersRead</code>","text":"<p>               Bases: <code>MCUMgrParametersReadRequest</code>, <code>_OSGroupBase</code></p> <p>Request MCU Manager parameters.</p> Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class MCUMgrParametersRead(smpos.MCUMgrParametersReadRequest, _OSGroupBase):\n    \"\"\"Request MCU Manager parameters.\n\n    \"\"\"\n    _Response = smpos.MCUMgrParametersReadResponse\n    _Response = smpos.MCUMgrParametersReadResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.OSApplicationInfoRead","title":"<code>OSApplicationInfoRead</code>","text":"<p>               Bases: <code>OSApplicationInfoReadRequest</code>, <code>_OSGroupBase</code></p> <p>Request information about the application running on the device.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str | None</code> required Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class OSApplicationInfoRead(smpos.OSApplicationInfoReadRequest, _OSGroupBase):\n    \"\"\"Request information about the application running on the device.\n\n    Args:\n        format (str | None): \n\n    \"\"\"\n    _Response = smpos.OSApplicationInfoReadResponse\n    _Response = smpos.OSApplicationInfoReadResponse\n</code></pre>"},{"location":"os_management/#smpclient.requests.os_management.BootloaderInformationRead","title":"<code>BootloaderInformationRead</code>","text":"<p>               Bases: <code>BootloaderInformationReadRequest</code>, <code>_OSGroupBase</code></p> <p>Request bootloader information.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> required Source code in <code>smpclient/requests/os_management.py</code> <pre><code>class BootloaderInformationRead(smpos.BootloaderInformationReadRequest, _OSGroupBase):\n    \"\"\"Request bootloader information.\n\n    Args:\n        query (str | None): \n\n    \"\"\"\n    _Response = smpos.BootloaderInformationReadResponse\n    _Response = smpos.BootloaderInformationReadResponse\n</code></pre>"},{"location":"requests/","title":"Requests Helpers","text":"<p>Refer to the smp documentation for a complete description of each SMP Request and Response.</p> <p>Generics and TypeGuards for SMP Requests and Responses.</p>"},{"location":"requests/#smpclient.generics.TEr1","title":"<code>TEr1 = TypeVar('TEr1', bound=smperror.ErrorV1)</code>  <code>module-attribute</code>","text":"<p>Type of SMP Error V1.</p>"},{"location":"requests/#smpclient.generics.TEr2","title":"<code>TEr2 = TypeVar('TEr2', bound=smperror.ErrorV2)</code>  <code>module-attribute</code>","text":"<p>Type of SMP Error V2.</p>"},{"location":"requests/#smpclient.generics.TRep","title":"<code>TRep = TypeVar('TRep', bound=Union[smpmessage.ReadResponse, smpmessage.WriteResponse])</code>  <code>module-attribute</code>","text":"<p>Type of successful SMP Response (ReadResponse or WriteResponse).</p>"},{"location":"requests/#smpclient.generics.SMPRequest","title":"<code>SMPRequest</code>","text":"<p>               Bases: <code>Protocol[TRep, TEr1, TEr2]</code></p> <p>A <code>Protocol</code> that groups the expected response and errors with a request.</p> <p>To use, inherit from an SMP Read or Write <code>Request</code> and define its expected <code>Response</code>, <code>ErrorV1</code>, and <code>ErrorV2</code>.</p> <p>Example: <pre><code>class ImageStatesRead(smpimg.ImageStatesReadRequest):\n    _Response = smpimg.ImageStatesReadResponse\n    _ErrorV1 = smpimg.ImageManagementErrorV1\n    _ErrorV2 = smpimg.ImageManagementErrorV2\n</code></pre></p> Source code in <code>smpclient/generics.py</code> <pre><code>class SMPRequest(Protocol[TRep, TEr1, TEr2]):\n    \"\"\"A `Protocol` that groups the expected response and errors with a request.\n\n    To use, inherit from an SMP Read or Write `Request` and define its expected\n    `Response`, `ErrorV1`, and `ErrorV2`.\n\n    Example:\n    ```python\n    class ImageStatesRead(smpimg.ImageStatesReadRequest):\n        _Response = smpimg.ImageStatesReadResponse\n        _ErrorV1 = smpimg.ImageManagementErrorV1\n        _ErrorV2 = smpimg.ImageManagementErrorV2\n    ```\n    \"\"\"\n\n    _Response: Type[TRep]\n    _ErrorV1: Type[TEr1]\n    _ErrorV2: Type[TEr2]\n\n    @property\n    def BYTES(self) -&gt; bytes:  # pragma: no cover\n        ...\n\n    @property\n    def header(self) -&gt; smphdr.Header:  # pragma: no cover\n        ...\n</code></pre>"},{"location":"requests/#smpclient.generics.SMPRequest.BYTES","title":"<code>BYTES: bytes</code>  <code>property</code>","text":""},{"location":"requests/#smpclient.generics.SMPRequest.header","title":"<code>header: smphdr.Header</code>  <code>property</code>","text":""},{"location":"requests/#smpclient.generics.error_v1","title":"<code>error_v1(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[smperror.ErrorV1]</code>","text":"<p><code>TypeGuard</code> that returns <code>True</code> if the <code>response</code> is an <code>ErrorV1</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ErrorV1 | TEr2 | TRep</code> <p>The response to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[ErrorV1]</code> <p><code>True</code> if the <code>response</code> is an <code>ErrorV1</code>.</p> Source code in <code>smpclient/generics.py</code> <pre><code>def error_v1(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[smperror.ErrorV1]:\n    \"\"\"`TypeGuard` that returns `True` if the `response` is an `ErrorV1`.\n\n    Args:\n        response: The response to check.\n\n    Returns:\n        `True` if the `response` is an `ErrorV1`.\n    \"\"\"\n    return response.RESPONSE_TYPE == smpmessage.ResponseType.ERROR_V1\n</code></pre>"},{"location":"requests/#smpclient.generics.error_v2","title":"<code>error_v2(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[TEr2]</code>","text":"<p><code>TypeGuard</code> that returns <code>True</code> if the <code>response</code> is an <code>ErrorV2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ErrorV1 | TEr2 | TRep</code> <p>The response to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[TEr2]</code> <p><code>True</code> if the <code>response</code> is an <code>ErrorV2</code>.</p> Source code in <code>smpclient/generics.py</code> <pre><code>def error_v2(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[TEr2]:\n    \"\"\"`TypeGuard` that returns `True` if the `response` is an `ErrorV2`.\n\n    Args:\n        response: The response to check.\n\n    Returns:\n        `True` if the `response` is an `ErrorV2`.\n    \"\"\"\n    return response.RESPONSE_TYPE == smpmessage.ResponseType.ERROR_V2\n</code></pre>"},{"location":"requests/#smpclient.generics.error","title":"<code>error(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[smperror.ErrorV1 | TEr2]</code>","text":"<p><code>TypeGuard</code> that returns <code>True</code> if the <code>response</code> is an <code>ErrorV1</code> or <code>ErrorV2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ErrorV1 | TEr2 | TRep</code> <p>The response to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[ErrorV1 | TEr2]</code> <p><code>True</code> if the <code>response</code> is an <code>ErrorV1</code> or <code>ErrorV2</code>.</p> Source code in <code>smpclient/generics.py</code> <pre><code>def error(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[smperror.ErrorV1 | TEr2]:\n    \"\"\"`TypeGuard` that returns `True` if the `response` is an `ErrorV1` or `ErrorV2`.\n\n    Args:\n        response: The response to check.\n\n    Returns:\n        `True` if the `response` is an `ErrorV1` or `ErrorV2`.\n    \"\"\"\n    return error_v1(response) or error_v2(response)\n</code></pre>"},{"location":"requests/#smpclient.generics.success","title":"<code>success(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[TRep]</code>","text":"<p><code>TypeGuard</code> that returns <code>True</code> if the <code>response</code> is a successful <code>Response</code>.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ErrorV1 | TEr2 | TRep</code> <p>The response to check.</p> required <p>Returns:</p> Type Description <code>TypeGuard[TRep]</code> <p><code>True</code> if the <code>response</code> is a successful <code>Response</code>.</p> Source code in <code>smpclient/generics.py</code> <pre><code>def success(response: smperror.ErrorV1 | TEr2 | TRep) -&gt; TypeGuard[TRep]:\n    \"\"\"`TypeGuard` that returns `True` if the `response` is a successful `Response`.\n\n    Args:\n        response: The response to check.\n\n    Returns:\n        `True` if the `response` is a successful `Response`.\n    \"\"\"\n    return response.RESPONSE_TYPE == smpmessage.ResponseType.SUCCESS\n</code></pre>"},{"location":"settings_management/","title":"Settings Management","text":"<p>Refer to the smp Settings Management documentation for a complete description of each Request and Response.</p>"},{"location":"settings_management/#smpclient.requests.settings_management.ReadSetting","title":"<code>ReadSetting</code>","text":"<p>               Bases: <code>ReadSettingRequest</code>, <code>_GroupBase</code></p> <p>Read setting.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>max_size</code> <code>int | None</code> required Source code in <code>smpclient/requests/settings_management.py</code> <pre><code>class ReadSetting(smpset.ReadSettingRequest, _GroupBase):\n    \"\"\"Read setting.\n\n    Args:\n        name (str): \n        max_size (int | None): \n\n    \"\"\"\n    _Response = smpset.ReadSettingResponse\n    _Response = smpset.ReadSettingResponse\n</code></pre>"},{"location":"settings_management/#smpclient.requests.settings_management.WriteSetting","title":"<code>WriteSetting</code>","text":"<p>               Bases: <code>WriteSettingRequest</code>, <code>_GroupBase</code></p> <p>Write setting.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>val</code> <code>bytes</code> required Source code in <code>smpclient/requests/settings_management.py</code> <pre><code>class WriteSetting(smpset.WriteSettingRequest, _GroupBase):\n    \"\"\"Write setting.\n\n    Args:\n        name (str): \n        val (bytes): \n\n    \"\"\"\n    _Response = smpset.WriteSettingResponse\n    _Response = smpset.WriteSettingResponse\n</code></pre>"},{"location":"settings_management/#smpclient.requests.settings_management.DeleteSetting","title":"<code>DeleteSetting</code>","text":"<p>               Bases: <code>DeleteSettingRequest</code>, <code>_GroupBase</code></p> <p>Delete setting.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required Source code in <code>smpclient/requests/settings_management.py</code> <pre><code>class DeleteSetting(smpset.DeleteSettingRequest, _GroupBase):\n    \"\"\"Delete setting.\n\n    Args:\n        name (str): \n\n    \"\"\"\n    _Response = smpset.DeleteSettingResponse\n    _Response = smpset.DeleteSettingResponse\n</code></pre>"},{"location":"settings_management/#smpclient.requests.settings_management.CommitSettings","title":"<code>CommitSettings</code>","text":"<p>               Bases: <code>CommitSettingsRequest</code>, <code>_GroupBase</code></p> <p>Commit pending settings.</p> <p>Commit settings command allows committing all settings that have been set but not yet applied on a device.</p> Source code in <code>smpclient/requests/settings_management.py</code> <pre><code>class CommitSettings(smpset.CommitSettingsRequest, _GroupBase):\n    \"\"\"Commit pending settings.\n\n\n    Commit settings command allows committing all settings that have been set\n    but not yet applied on a device.\n\n    \"\"\"\n    _Response = smpset.CommitSettingsResponse\n    _Response = smpset.CommitSettingsResponse\n</code></pre>"},{"location":"settings_management/#smpclient.requests.settings_management.LoadSettings","title":"<code>LoadSettings</code>","text":"<p>               Bases: <code>LoadSettingsRequest</code>, <code>_GroupBase</code></p> <p>Load settings from persistent storage.</p> Source code in <code>smpclient/requests/settings_management.py</code> <pre><code>class LoadSettings(smpset.LoadSettingsRequest, _GroupBase):\n    \"\"\"Load settings from persistent storage.\n\n    \"\"\"\n    _Response = smpset.LoadSettingsResponse\n    _Response = smpset.LoadSettingsResponse\n</code></pre>"},{"location":"settings_management/#smpclient.requests.settings_management.SaveSettings","title":"<code>SaveSettings</code>","text":"<p>               Bases: <code>SaveSettingsRequest</code>, <code>_GroupBase</code></p> <p>Save settings to persistent storage.</p> Source code in <code>smpclient/requests/settings_management.py</code> <pre><code>class SaveSettings(smpset.SaveSettingsRequest, _GroupBase):\n    \"\"\"Save settings to persistent storage.\n\n    \"\"\"\n    _Response = smpset.SaveSettingsResponse\n    _Response = smpset.SaveSettingsResponse\n</code></pre>"},{"location":"shell_management/","title":"Shell Management","text":"<p>Refer to the smp Shell Management documentation for a complete description of each Request and Response.</p>"},{"location":"shell_management/#smpclient.requests.shell_management.Execute","title":"<code>Execute</code>","text":"<p>               Bases: <code>ExecuteRequest</code>, <code>_ShellGroupBase</code></p> <p>Execute a shell command.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>List[str]</code> required Source code in <code>smpclient/requests/shell_management.py</code> <pre><code>class Execute(smpshell.ExecuteRequest, _ShellGroupBase):\n    \"\"\"Execute a shell command.\n\n    Args:\n        argv (List[str]): \n\n    \"\"\"\n    _Response = smpshell.ExecuteResponse\n    _Response = smpshell.ExecuteResponse\n</code></pre>"},{"location":"statistics_management/","title":"Statistics Management","text":"<p>Refer to the smp Statistics Management documentation for a complete description of each Request and Response.</p>"},{"location":"statistics_management/#smpclient.requests.statistics_management.GroupData","title":"<code>GroupData</code>","text":"<p>               Bases: <code>GroupDataRequest</code>, <code>_GroupBase</code></p> <p>Read the statistics group data.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required Source code in <code>smpclient/requests/statistics_management.py</code> <pre><code>class GroupData(smpstat.GroupDataRequest, _GroupBase):\n    \"\"\"Read the statistics group data.\n\n    Args:\n        name (str): \n\n    \"\"\"\n    _Response = smpstat.GroupDataResponse\n    _Response = smpstat.GroupDataResponse\n</code></pre>"},{"location":"statistics_management/#smpclient.requests.statistics_management.ListOfGroups","title":"<code>ListOfGroups</code>","text":"<p>               Bases: <code>ListOfGroupsRequest</code>, <code>_GroupBase</code></p> <p>List the available statistics groups.</p> Source code in <code>smpclient/requests/statistics_management.py</code> <pre><code>class ListOfGroups(smpstat.ListOfGroupsRequest, _GroupBase):\n    \"\"\"List the available statistics groups.\n\n    \"\"\"\n    _Response = smpstat.ListOfGroupsResponse\n    _Response = smpstat.ListOfGroupsResponse\n</code></pre>"},{"location":"zephyr_management/","title":"Zephyr Management","text":"<p>Refer to the smp Zephyr Management documentation for a complete description of each Request and Response.</p>"},{"location":"zephyr_management/#smpclient.requests.zephyr_management.EraseStorage","title":"<code>EraseStorage</code>","text":"<p>               Bases: <code>EraseStorageRequest</code>, <code>_GroupBase</code></p> <p>Erase the storage area.</p> Source code in <code>smpclient/requests/zephyr_management.py</code> <pre><code>class EraseStorage(smpz.EraseStorageRequest, _GroupBase):\n    \"\"\"Erase the storage area.\n\n    \"\"\"\n    _Response = smpz.EraseStorageResponse\n    _Response = smpz.EraseStorageResponse\n</code></pre>"},{"location":"transport/ble/","title":"Bluetooth Low Energy (BLE)","text":"<p>A Bluetooth Low Energy (BLE) SMPTransport.</p>"},{"location":"transport/ble/#smpclient.transport.ble.SMP_SERVICE_UUID","title":"<code>SMP_SERVICE_UUID: Final = UUID('8D53DC1D-1DB7-4CD3-868B-8A527460AA84')</code>  <code>module-attribute</code>","text":""},{"location":"transport/ble/#smpclient.transport.ble.SMP_CHARACTERISTIC_UUID","title":"<code>SMP_CHARACTERISTIC_UUID: Final = UUID('DA2E7828-FBCE-4E01-AE9E-261174997C48')</code>  <code>module-attribute</code>","text":""},{"location":"transport/ble/#smpclient.transport.ble.MAC_ADDRESS_PATTERN","title":"<code>MAC_ADDRESS_PATTERN: Final = re.compile('([0-9A-F]{2}[:]){5}[0-9A-F]{2}$', flags=re.IGNORECASE)</code>  <code>module-attribute</code>","text":""},{"location":"transport/ble/#smpclient.transport.ble.UUID_PATTERN","title":"<code>UUID_PATTERN: Final = re.compile('^[a-f0-9]{8}-?[a-f0-9]{4}-?4[a-f0-9]{3}-?[89ab][a-f0-9]{3}-?[a-f0-9]{12}\\\\Z', flags=re.IGNORECASE)</code>  <code>module-attribute</code>","text":""},{"location":"transport/ble/#smpclient.transport.ble.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"transport/ble/#smpclient.transport.ble.GattSession","title":"<code>GattSession</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>class GattSession(Protocol):\n    max_pdu_size: int\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.GattSession.max_pdu_size","title":"<code>max_pdu_size: int</code>  <code>instance-attribute</code>","text":""},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransportException","title":"<code>SMPBLETransportException</code>","text":"<p>               Bases: <code>SMPClientException</code></p> <p>Base class for SMP BLE transport exceptions.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>class SMPBLETransportException(SMPClientException):\n    \"\"\"Base class for SMP BLE transport exceptions.\"\"\"\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransportDeviceNotFound","title":"<code>SMPBLETransportDeviceNotFound</code>","text":"<p>               Bases: <code>SMPBLETransportException</code></p> <p>Raised when a BLE device is not found.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>class SMPBLETransportDeviceNotFound(SMPBLETransportException):\n    \"\"\"Raised when a BLE device is not found.\"\"\"\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransportNotSMPServer","title":"<code>SMPBLETransportNotSMPServer</code>","text":"<p>               Bases: <code>SMPBLETransportException</code></p> <p>Raised when the SMP characteristic UUID is not found.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>class SMPBLETransportNotSMPServer(SMPBLETransportException):\n    \"\"\"Raised when the SMP characteristic UUID is not found.\"\"\"\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport","title":"<code>SMPBLETransport</code>","text":"<p>               Bases: <code>SMPTransport</code></p> <p>A Bluetooth Low Energy (BLE) SMPTransport.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>class SMPBLETransport(SMPTransport):\n    \"\"\"A Bluetooth Low Energy (BLE) SMPTransport.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self._buffer = bytearray()\n        self._notify_condition = asyncio.Condition()\n        self._disconnected_event = asyncio.Event()\n        self._disconnected_event.set()\n\n        self._max_write_without_response_size = 20\n        \"\"\"Initially set to BLE minimum; may be mutated by the `connect()` method.\"\"\"\n\n        logger.debug(f\"Initialized {self.__class__.__name__}\")\n\n    @override\n    async def connect(self, address: str, timeout_s: float) -&gt; None:\n        logger.debug(f\"Scanning for {address=}\")\n        device: BLEDevice | None = (\n            await BleakScanner.find_device_by_address(address, timeout=timeout_s)\n            if MAC_ADDRESS_PATTERN.match(address) or UUID_PATTERN.match(address)\n            else await BleakScanner.find_device_by_name(address)\n        )\n\n        if type(device) is BLEDevice:\n            self._client = BleakClient(\n                device,\n                services=(str(SMP_SERVICE_UUID),),\n                disconnected_callback=self._set_disconnected_event,\n            )\n        else:\n            raise SMPBLETransportDeviceNotFound(f\"Device '{address}' not found\")\n\n        logger.debug(f\"Found device: {device=}, connecting...\")\n        await self._client.connect()\n        self._disconnected_event.clear()\n        logger.debug(f\"Connected to {device=}\")\n\n        smp_characteristic = self._client.services.get_characteristic(SMP_CHARACTERISTIC_UUID)\n        if smp_characteristic is None:\n            raise SMPBLETransportNotSMPServer(\"Missing the SMP characteristic UUID.\")\n\n        logger.debug(f\"Found SMP characteristic: {smp_characteristic=}\")\n        logger.info(f\"{smp_characteristic.max_write_without_response_size=}\")\n        self._max_write_without_response_size = smp_characteristic.max_write_without_response_size\n        if (\n            self._winrt_backend(self._client._backend)\n            and self._max_write_without_response_size == 20\n        ):\n            # https://github.com/hbldh/bleak/pull/1552#issuecomment-2105573291\n            logger.warning(\n                \"The SMP characteristic MTU is 20 bytes, possibly a Windows bug, checking again\"\n            )\n            await asyncio.sleep(2)\n            smp_characteristic._max_write_without_response_size = (\n                self._client._backend._session.max_pdu_size - 3  # type: ignore\n            )\n            self._max_write_without_response_size = (\n                smp_characteristic.max_write_without_response_size\n            )\n            logger.warning(f\"{smp_characteristic.max_write_without_response_size=}\")\n        elif self._bluez_backend(self._client._backend):\n            logger.debug(\"Getting MTU from BlueZ backend\")\n            await self._client._backend._acquire_mtu()\n            logger.debug(f\"Got MTU: {self._client.mtu_size}\")\n            self._max_write_without_response_size = self._client.mtu_size - 3\n\n        logger.info(f\"{self._max_write_without_response_size=}\")\n        self._smp_characteristic = smp_characteristic\n\n        logger.debug(f\"Starting notify on {SMP_CHARACTERISTIC_UUID=}\")\n        await self._client.start_notify(SMP_CHARACTERISTIC_UUID, self._notify_callback)\n        logger.debug(f\"Started notify on {SMP_CHARACTERISTIC_UUID=}\")\n\n    @override\n    async def disconnect(self) -&gt; None:\n        logger.debug(f\"Disonnecting from {self._client.address}\")\n        await self._client.disconnect()\n        logger.debug(f\"Disconnected from {self._client.address}\")\n\n    @override\n    async def send(self, data: bytes) -&gt; None:\n        logger.debug(f\"Sending {len(data)} bytes, {self.mtu=}\")\n        for offset in range(0, len(data), self.mtu):\n            await self._client.write_gatt_char(\n                self._smp_characteristic, data[offset : offset + self.mtu], response=False\n            )\n        logger.debug(f\"Sent {len(data)} bytes\")\n\n    @override\n    async def receive(self) -&gt; bytes:\n        # Note: self._buffer is mutated asynchronously by this method and self._notify_callback().\n        #       self._notify_condition is used to synchronize access to self._buffer.\n\n        async with self._notify_condition:  # wait for the header\n            logger.debug(f\"Waiting for notify on {SMP_CHARACTERISTIC_UUID=}\")\n            await self._notify_or_disconnect()\n\n            if len(self._buffer) &lt; smphdr.Header.SIZE:  # pragma: no cover\n                raise SMPBLETransportException(\n                    f\"Buffer contents not big enough for SMP header: {self._buffer=}\"\n                )\n\n            header: Final = smphdr.Header.loads(self._buffer[: smphdr.Header.SIZE])\n            logger.debug(f\"Received {header=}\")\n\n        message_length: Final = header.length + header.SIZE\n        logger.debug(f\"Waiting for the rest of the {message_length} byte response\")\n\n        while True:  # wait for the rest of the message\n            async with self._notify_condition:\n                if len(self._buffer) == message_length:\n                    logger.debug(f\"Finished receiving {message_length} byte response\")\n                    out = bytes(self._buffer)\n                    self._buffer.clear()\n                    return out\n                elif len(self._buffer) &gt; message_length:  # pragma: no cover\n                    raise SMPBLETransportException(\"Length of buffer passed expected message size.\")\n                await self._notify_or_disconnect()\n\n    async def _notify_callback(self, sender: BleakGATTCharacteristic, data: bytes) -&gt; None:\n        if sender.uuid != str(SMP_CHARACTERISTIC_UUID):  # pragma: no cover\n            raise SMPBLETransportException(f\"Unexpected notify from {sender}; {data=}\")\n        async with self._notify_condition:\n            logger.debug(f\"Received {len(data)} bytes from {SMP_CHARACTERISTIC_UUID=}\")\n            self._buffer.extend(data)\n            self._notify_condition.notify()\n\n    async def send_and_receive(self, data: bytes) -&gt; bytes:\n        await self.send(data)\n        return await self.receive()\n\n    @override\n    @property\n    def mtu(self) -&gt; int:\n        return self._max_write_without_response_size\n\n    @staticmethod\n    async def scan(timeout: int = 5) -&gt; List[BLEDevice]:\n        \"\"\"Scan for BLE devices.\"\"\"\n        logger.debug(f\"Scanning for BLE devices for {timeout} seconds\")\n        devices: Final = await BleakScanner(service_uuids=[str(SMP_SERVICE_UUID)]).discover(\n            timeout=timeout, return_adv=True\n        )\n        smp_servers: Final = [\n            d for d, a in devices.values() if SMP_SERVICE_UUID in {UUID(u) for u in a.service_uuids}\n        ]\n        logger.debug(f\"Found {len(smp_servers)} SMP devices: {smp_servers=}\")\n        return smp_servers\n\n    @staticmethod\n    def _bluez_backend(client_backend: BaseBleakClient) -&gt; TypeGuard[BleakClientBlueZDBus]:\n        return client_backend.__class__.__name__ == \"BleakClientBlueZDBus\"\n\n    @staticmethod\n    def _winrt_backend(client_backend: BaseBleakClient) -&gt; TypeGuard[BleakClientWinRT]:\n        return client_backend.__class__.__name__ == \"BleakClientWinRT\"\n\n    def _set_disconnected_event(self, client: BleakClient) -&gt; None:\n        if client is not self._client:\n            raise SMPBLETransportException(\n                f\"Unexpected client disconnected: {client=}, {self._client=}\"\n            )\n        logger.warning(f\"Disconnected from {client.address}\")\n        self._disconnected_event.set()\n\n    async def _notify_or_disconnect(self) -&gt; None:\n        disconnected_task: Final = asyncio.create_task(self._disconnected_event.wait())\n        notify_task: Final = asyncio.create_task(self._notify_condition.wait())\n        done, pending = await asyncio.wait(\n            (disconnected_task, notify_task), return_when=asyncio.FIRST_COMPLETED\n        )\n        for task in pending:\n            task.cancel()\n        try:\n            await asyncio.gather(*pending)\n        except asyncio.CancelledError:\n            pass\n        if disconnected_task in done:\n            raise SMPTransportDisconnected(\n                f\"{self.__class__.__name__} disconnected from {self._client.address}\"\n            )\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.mtu","title":"<code>mtu: int</code>  <code>property</code>","text":"<p>The Maximum Transmission Unit (MTU) in 8-bit bytes.</p>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.__init__","title":"<code>__init__() -&gt; None</code>","text":"Source code in <code>smpclient/transport/ble.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._buffer = bytearray()\n    self._notify_condition = asyncio.Condition()\n    self._disconnected_event = asyncio.Event()\n    self._disconnected_event.set()\n\n    self._max_write_without_response_size = 20\n    \"\"\"Initially set to BLE minimum; may be mutated by the `connect()` method.\"\"\"\n\n    logger.debug(f\"Initialized {self.__class__.__name__}\")\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.connect","title":"<code>connect(address: str, timeout_s: float) -&gt; None</code>  <code>async</code>","text":"<p>Connect the <code>SMPTransport</code>.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The SMP server address.</p> required <code>timeout_s</code> <code>float</code> <p>The connection timeout in seconds.</p> required Source code in <code>smpclient/transport/ble.py</code> <pre><code>@override\nasync def connect(self, address: str, timeout_s: float) -&gt; None:\n    logger.debug(f\"Scanning for {address=}\")\n    device: BLEDevice | None = (\n        await BleakScanner.find_device_by_address(address, timeout=timeout_s)\n        if MAC_ADDRESS_PATTERN.match(address) or UUID_PATTERN.match(address)\n        else await BleakScanner.find_device_by_name(address)\n    )\n\n    if type(device) is BLEDevice:\n        self._client = BleakClient(\n            device,\n            services=(str(SMP_SERVICE_UUID),),\n            disconnected_callback=self._set_disconnected_event,\n        )\n    else:\n        raise SMPBLETransportDeviceNotFound(f\"Device '{address}' not found\")\n\n    logger.debug(f\"Found device: {device=}, connecting...\")\n    await self._client.connect()\n    self._disconnected_event.clear()\n    logger.debug(f\"Connected to {device=}\")\n\n    smp_characteristic = self._client.services.get_characteristic(SMP_CHARACTERISTIC_UUID)\n    if smp_characteristic is None:\n        raise SMPBLETransportNotSMPServer(\"Missing the SMP characteristic UUID.\")\n\n    logger.debug(f\"Found SMP characteristic: {smp_characteristic=}\")\n    logger.info(f\"{smp_characteristic.max_write_without_response_size=}\")\n    self._max_write_without_response_size = smp_characteristic.max_write_without_response_size\n    if (\n        self._winrt_backend(self._client._backend)\n        and self._max_write_without_response_size == 20\n    ):\n        # https://github.com/hbldh/bleak/pull/1552#issuecomment-2105573291\n        logger.warning(\n            \"The SMP characteristic MTU is 20 bytes, possibly a Windows bug, checking again\"\n        )\n        await asyncio.sleep(2)\n        smp_characteristic._max_write_without_response_size = (\n            self._client._backend._session.max_pdu_size - 3  # type: ignore\n        )\n        self._max_write_without_response_size = (\n            smp_characteristic.max_write_without_response_size\n        )\n        logger.warning(f\"{smp_characteristic.max_write_without_response_size=}\")\n    elif self._bluez_backend(self._client._backend):\n        logger.debug(\"Getting MTU from BlueZ backend\")\n        await self._client._backend._acquire_mtu()\n        logger.debug(f\"Got MTU: {self._client.mtu_size}\")\n        self._max_write_without_response_size = self._client.mtu_size - 3\n\n    logger.info(f\"{self._max_write_without_response_size=}\")\n    self._smp_characteristic = smp_characteristic\n\n    logger.debug(f\"Starting notify on {SMP_CHARACTERISTIC_UUID=}\")\n    await self._client.start_notify(SMP_CHARACTERISTIC_UUID, self._notify_callback)\n    logger.debug(f\"Started notify on {SMP_CHARACTERISTIC_UUID=}\")\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.disconnect","title":"<code>disconnect() -&gt; None</code>  <code>async</code>","text":"<p>Disconnect the <code>SMPTransport</code>.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>@override\nasync def disconnect(self) -&gt; None:\n    logger.debug(f\"Disonnecting from {self._client.address}\")\n    await self._client.disconnect()\n    logger.debug(f\"Disconnected from {self._client.address}\")\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.send","title":"<code>send(data: bytes) -&gt; None</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required Source code in <code>smpclient/transport/ble.py</code> <pre><code>@override\nasync def send(self, data: bytes) -&gt; None:\n    logger.debug(f\"Sending {len(data)} bytes, {self.mtu=}\")\n    for offset in range(0, len(data), self.mtu):\n        await self._client.write_gatt_char(\n            self._smp_characteristic, data[offset : offset + self.mtu], response=False\n        )\n    logger.debug(f\"Sent {len(data)} bytes\")\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.receive","title":"<code>receive() -&gt; bytes</code>  <code>async</code>","text":"<p>Receive the decoded <code>SMPResponse</code> data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>@override\nasync def receive(self) -&gt; bytes:\n    # Note: self._buffer is mutated asynchronously by this method and self._notify_callback().\n    #       self._notify_condition is used to synchronize access to self._buffer.\n\n    async with self._notify_condition:  # wait for the header\n        logger.debug(f\"Waiting for notify on {SMP_CHARACTERISTIC_UUID=}\")\n        await self._notify_or_disconnect()\n\n        if len(self._buffer) &lt; smphdr.Header.SIZE:  # pragma: no cover\n            raise SMPBLETransportException(\n                f\"Buffer contents not big enough for SMP header: {self._buffer=}\"\n            )\n\n        header: Final = smphdr.Header.loads(self._buffer[: smphdr.Header.SIZE])\n        logger.debug(f\"Received {header=}\")\n\n    message_length: Final = header.length + header.SIZE\n    logger.debug(f\"Waiting for the rest of the {message_length} byte response\")\n\n    while True:  # wait for the rest of the message\n        async with self._notify_condition:\n            if len(self._buffer) == message_length:\n                logger.debug(f\"Finished receiving {message_length} byte response\")\n                out = bytes(self._buffer)\n                self._buffer.clear()\n                return out\n            elif len(self._buffer) &gt; message_length:  # pragma: no cover\n                raise SMPBLETransportException(\"Length of buffer passed expected message size.\")\n            await self._notify_or_disconnect()\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.send_and_receive","title":"<code>send_and_receive(data: bytes) -&gt; bytes</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code> and receive the decoded <code>SMPResponse</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>async def send_and_receive(self, data: bytes) -&gt; bytes:\n    await self.send(data)\n    return await self.receive()\n</code></pre>"},{"location":"transport/ble/#smpclient.transport.ble.SMPBLETransport.scan","title":"<code>scan(timeout: int = 5) -&gt; List[BLEDevice]</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Scan for BLE devices.</p> Source code in <code>smpclient/transport/ble.py</code> <pre><code>@staticmethod\nasync def scan(timeout: int = 5) -&gt; List[BLEDevice]:\n    \"\"\"Scan for BLE devices.\"\"\"\n    logger.debug(f\"Scanning for BLE devices for {timeout} seconds\")\n    devices: Final = await BleakScanner(service_uuids=[str(SMP_SERVICE_UUID)]).discover(\n        timeout=timeout, return_adv=True\n    )\n    smp_servers: Final = [\n        d for d, a in devices.values() if SMP_SERVICE_UUID in {UUID(u) for u in a.service_uuids}\n    ]\n    logger.debug(f\"Found {len(smp_servers)} SMP devices: {smp_servers=}\")\n    return smp_servers\n</code></pre>"},{"location":"transport/serial/","title":"Serial","text":"<p>A serial SMPTransport.</p> <p>In addition to UART, this transport can be used with USB CDC ACM and CAN.</p>"},{"location":"transport/serial/#smpclient.transport.serial.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport","title":"<code>SMPSerialTransport</code>","text":"<p>               Bases: <code>SMPTransport</code></p> Source code in <code>smpclient/transport/serial.py</code> <pre><code>class SMPSerialTransport(SMPTransport):\n    _POLLING_INTERVAL_S = 0.005\n    _CONNECTION_RETRY_INTERVAL_S = 0.500\n\n    class _ReadBuffer:\n        \"\"\"The state of the read buffer.\"\"\"\n\n        @unique\n        class State(IntEnum):\n            SMP = 0\n            \"\"\"An SMP start or continue delimiter has been received and the\n            `smp_buffer` is being filled with the remainder of the SMP packet.\n            \"\"\"\n\n            SER = 1\n            \"\"\"The SMP start delimiter has not been received and the\n            `ser_buffer` is being filled with data.\n            \"\"\"\n\n        def __init__(self) -&gt; None:\n            self.smp = bytearray([])\n            \"\"\"The buffer for the SMP packet.\"\"\"\n\n            self.ser = bytearray([])\n            \"\"\"The buffer for serial data that is not part of an SMP packet.\"\"\"\n\n            self.state = SMPSerialTransport._ReadBuffer.State.SER\n            \"\"\"The state of the read buffer.\"\"\"\n\n    def __init__(  # noqa: DOC301\n        self,\n        max_smp_encoded_frame_size: int = 256,\n        line_length: int = 128,\n        line_buffers: int = 2,\n        baudrate: int = 115200,\n        bytesize: int = 8,\n        parity: str = \"N\",\n        stopbits: float = 1,\n        timeout: float | None = None,\n        xonxoff: bool = False,\n        rtscts: bool = False,\n        write_timeout: float | None = None,\n        dsrdtr: bool = False,\n        inter_byte_timeout: float | None = None,\n        exclusive: bool | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the serial transport.\n\n        Args:\n            max_smp_encoded_frame_size: The maximum size of an encoded SMP\n                frame.  The SMP server needs to have a buffer large enough to\n                receive the encoded frame packets and to store the decoded frame.\n            line_length: The maximum SMP packet size.\n            line_buffers: The number of line buffers in the serial buffer.\n            baudrate: The baudrate of the serial connection.  OK to ignore for\n                USB CDC ACM.\n            bytesize: The number of data bits.\n            parity: The parity setting.\n            stopbits: The number of stop bits.\n            timeout: The read timeout.\n            xonxoff: Enable software flow control.\n            rtscts: Enable hardware (RTS/CTS) flow control.\n            write_timeout: The write timeout.\n            dsrdtr: Enable hardware (DSR/DTR) flow control.\n            inter_byte_timeout: The inter-byte timeout.\n            exclusive: The exclusive access timeout.\n\n        \"\"\"\n        if max_smp_encoded_frame_size &lt; line_length * line_buffers:\n            logger.error(\n                f\"{max_smp_encoded_frame_size=} is less than {line_length=} * {line_buffers=}!\"\n            )\n        elif max_smp_encoded_frame_size != line_length * line_buffers:\n            logger.warning(\n                f\"{max_smp_encoded_frame_size=} is not equal to {line_length=} * {line_buffers=}!\"\n            )\n\n        self._max_smp_encoded_frame_size: Final = max_smp_encoded_frame_size\n        self._line_length: Final = line_length\n        self._line_buffers: Final = line_buffers\n        self._conn: Final = Serial(\n            baudrate=baudrate,\n            bytesize=bytesize,\n            parity=parity,\n            stopbits=stopbits,\n            timeout=timeout,\n            xonxoff=xonxoff,\n            rtscts=rtscts,\n            write_timeout=write_timeout,\n            dsrdtr=dsrdtr,\n            inter_byte_timeout=inter_byte_timeout,\n            exclusive=exclusive,\n        )\n        self._buffer = SMPSerialTransport._ReadBuffer()\n        logger.debug(f\"Initialized {self.__class__.__name__}\")\n\n    @override\n    async def connect(self, address: str, timeout_s: float) -&gt; None:\n        self._conn.port = address\n        logger.debug(f\"Connecting to {self._conn.port=}\")\n        start_time: Final = time.time()\n        while time.time() - start_time &lt;= timeout_s:\n            try:\n                self._conn.open()\n                logger.debug(f\"Connected to {self._conn.port=}\")\n                return\n            except SerialException as e:\n                logger.debug(\n                    f\"Failed to connect to {self._conn.port=}: {e}, \"\n                    f\"retrying in {SMPSerialTransport._CONNECTION_RETRY_INTERVAL_S} seconds\"\n                )\n                await asyncio.sleep(SMPSerialTransport._CONNECTION_RETRY_INTERVAL_S)\n\n        raise TimeoutError(f\"Failed to connect to {address=}\")\n\n    @override\n    async def disconnect(self) -&gt; None:\n        logger.debug(f\"Disconnecting from {self._conn.port=}\")\n        self._conn.close()\n        logger.debug(f\"Disconnected from {self._conn.port=}\")\n\n    @override\n    async def send(self, data: bytes) -&gt; None:\n        if len(data) &gt; self.max_unencoded_size:\n            raise ValueError(\n                f\"Data size {len(data)} exceeds maximum unencoded size {self.max_unencoded_size}\"\n            )\n        logger.debug(f\"Sending {len(data)} bytes\")\n        try:\n            for packet in smppacket.encode(data, line_length=self._line_length):\n                self._conn.write(packet)\n                logger.debug(f\"Writing encoded packet of size {len(packet)}B; {self._line_length=}\")\n\n            # fake async until I get around to replacing pyserial\n            while self._conn.out_waiting &gt; 0:\n                await asyncio.sleep(SMPSerialTransport._POLLING_INTERVAL_S)\n        except SerialException as e:\n            logger.error(f\"Failed to send {len(data)} bytes: {e}\")\n            raise SMPTransportDisconnected(\n                f\"{self.__class__.__name__} disconnected from {self._conn.port}\"\n            )\n\n        logger.debug(f\"Sent {len(data)} bytes\")\n\n    @override\n    async def receive(self) -&gt; bytes:\n        decoder = smppacket.decode()\n        next(decoder)\n\n        logger.debug(\"Waiting for response\")\n        while True:\n            try:\n                b = await self._readuntil()\n                decoder.send(b)\n            except StopIteration as e:\n                logger.debug(f\"Finished receiving {len(e.value)} byte response\")\n                return e.value\n            except SerialException as e:\n                logger.error(f\"Failed to receive response: {e}\")\n                raise SMPTransportDisconnected(\n                    f\"{self.__class__.__name__} disconnected from {self._conn.port}\"\n                )\n\n    async def _readuntil(self) -&gt; bytes:\n        \"\"\"Read `bytes` until the `delimiter` then return the `bytes` including the `delimiter`.\"\"\"\n\n        START_DELIMITER: Final = smppacket.SIXTY_NINE\n        CONTINUE_DELIMITER: Final = smppacket.FOUR_TWENTY\n        END_DELIMITER: Final = b\"\\n\"\n\n        # fake async until I get around to replacing pyserial\n\n        i_smp_start = 0\n        i_smp_end = 0\n        i_start: int | None = None\n        i_continue: int | None = None\n        while True:\n            if self._buffer.state == SMPSerialTransport._ReadBuffer.State.SER:\n                # read the entire OS buffer\n                try:\n                    self._buffer.ser.extend(self._conn.read_all() or [])\n                except StopIteration:\n                    pass\n\n                try:  # search the buffer for the index of the start delimiter\n                    i_start = self._buffer.ser.index(START_DELIMITER)\n                except ValueError:\n                    i_start = None\n\n                try:  # search the buffer for the index of the continue delimiter\n                    i_continue = self._buffer.ser.index(CONTINUE_DELIMITER)\n                except ValueError:\n                    i_continue = None\n\n                if i_start is not None and i_continue is not None:\n                    i_smp_start = min(i_start, i_continue)\n                elif i_start is not None:\n                    i_smp_start = i_start\n                elif i_continue is not None:\n                    i_smp_start = i_continue\n                else:  # no delimiters found yet, clear non SMP data and wait\n                    while True:\n                        try:  # search the buffer for newline characters\n                            i = self._buffer.ser.index(b\"\\n\")\n                            try:  # log as a string if possible\n                                logger.warning(\n                                    f\"{self._conn.port}: {self._buffer.ser[:i].decode()}\"\n                                )\n                            except UnicodeDecodeError:  # log as bytes if not\n                                logger.warning(f\"{self._conn.port}: {self._buffer.ser[:i].hex()}\")\n                            self._buffer.ser = self._buffer.ser[i + 1 :]\n                        except ValueError:\n                            break\n                    await asyncio.sleep(SMPSerialTransport._POLLING_INTERVAL_S)\n                    continue\n\n                if i_smp_start != 0:  # log the rest of the serial buffer\n                    try:  # log as a string if possible\n                        logger.warning(\n                            f\"{self._conn.port}: {self._buffer.ser[:i_smp_start].decode()}\"\n                        )\n                    except UnicodeDecodeError:  # log as bytes if not\n                        logger.warning(f\"{self._conn.port}: {self._buffer.ser[:i_smp_start].hex()}\")\n\n                self._buffer.smp = self._buffer.ser[i_smp_start:]\n                self._buffer.ser.clear()\n                self._buffer.state = SMPSerialTransport._ReadBuffer.State.SMP\n                i_smp_end = 0\n\n                # don't await since the buffer may already contain the end delimiter\n\n            elif self._buffer.state == SMPSerialTransport._ReadBuffer.State.SMP:\n                # read the entire OS buffer\n                try:\n                    self._buffer.smp.extend(self._conn.read_all() or [])\n                except StopIteration:\n                    pass\n\n                try:  # search the buffer for the index of the delimiter\n                    i_smp_end = self._buffer.smp.index(END_DELIMITER, i_smp_end) + len(\n                        END_DELIMITER\n                    )\n                except ValueError:  # delimiter not found yet, wait\n                    await asyncio.sleep(SMPSerialTransport._POLLING_INTERVAL_S)\n                    continue\n\n                # out is everything up to and including the delimiter\n                out = self._buffer.smp[:i_smp_end]\n                logger.debug(f\"Received {len(out)} byte chunk\")\n\n                # there may be some leftover to save for the next read, but\n                # it's not necessarily SMP data\n                self._buffer.ser = self._buffer.smp[i_smp_end:]\n\n                self._buffer.state = SMPSerialTransport._ReadBuffer.State.SER\n\n                return out\n\n    @override\n    async def send_and_receive(self, data: bytes) -&gt; bytes:\n        await self.send(data)\n        return await self.receive()\n\n    @override\n    @property\n    def mtu(self) -&gt; int:\n        return self._max_smp_encoded_frame_size\n\n    @override\n    @cached_property\n    def max_unencoded_size(self) -&gt; int:\n        \"\"\"The serial transport encodes each packet instead of sending SMP messages as raw bytes.\"\"\"\n\n        # For each packet, AKA line_buffer, include the cost of the base64\n        # encoded frame_length and CRC16 and the start/continue delimiter.\n        # Add to that the cost of the stop delimiter.\n        packet_framing_size: Final = (\n            _base64_cost(smppacket.FRAME_LENGTH_STRUCT.size + smppacket.CRC16_STRUCT.size)\n            + smppacket.DELIMITER_SIZE\n        ) * self._line_buffers + len(smppacket.END_DELIMITER)\n\n        # Get the number of unencoded bytes that can fit in self.mtu and\n        # subtract the cost of framing the separate packets.\n        # This is the maximum number of unencoded bytes that can be received by\n        # the SMP server with this transport configuration.\n        return _base64_max(self.mtu) - packet_framing_size\n</code></pre>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.mtu","title":"<code>mtu: int</code>  <code>property</code>","text":"<p>The Maximum Transmission Unit (MTU) in 8-bit bytes.</p>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.max_unencoded_size","title":"<code>max_unencoded_size: int</code>  <code>cached</code> <code>property</code>","text":"<p>The serial transport encodes each packet instead of sending SMP messages as raw bytes.</p>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.__init__","title":"<code>__init__(max_smp_encoded_frame_size: int = 256, line_length: int = 128, line_buffers: int = 2, baudrate: int = 115200, bytesize: int = 8, parity: str = 'N', stopbits: float = 1, timeout: float | None = None, xonxoff: bool = False, rtscts: bool = False, write_timeout: float | None = None, dsrdtr: bool = False, inter_byte_timeout: float | None = None, exclusive: bool | None = None) -&gt; None</code>","text":"<p>Initialize the serial transport.</p> <p>Parameters:</p> Name Type Description Default <code>max_smp_encoded_frame_size</code> <code>int</code> <p>The maximum size of an encoded SMP frame.  The SMP server needs to have a buffer large enough to receive the encoded frame packets and to store the decoded frame.</p> <code>256</code> <code>line_length</code> <code>int</code> <p>The maximum SMP packet size.</p> <code>128</code> <code>line_buffers</code> <code>int</code> <p>The number of line buffers in the serial buffer.</p> <code>2</code> <code>baudrate</code> <code>int</code> <p>The baudrate of the serial connection.  OK to ignore for USB CDC ACM.</p> <code>115200</code> <code>bytesize</code> <code>int</code> <p>The number of data bits.</p> <code>8</code> <code>parity</code> <code>str</code> <p>The parity setting.</p> <code>'N'</code> <code>stopbits</code> <code>float</code> <p>The number of stop bits.</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>The read timeout.</p> <code>None</code> <code>xonxoff</code> <code>bool</code> <p>Enable software flow control.</p> <code>False</code> <code>rtscts</code> <code>bool</code> <p>Enable hardware (RTS/CTS) flow control.</p> <code>False</code> <code>write_timeout</code> <code>float | None</code> <p>The write timeout.</p> <code>None</code> <code>dsrdtr</code> <code>bool</code> <p>Enable hardware (DSR/DTR) flow control.</p> <code>False</code> <code>inter_byte_timeout</code> <code>float | None</code> <p>The inter-byte timeout.</p> <code>None</code> <code>exclusive</code> <code>bool | None</code> <p>The exclusive access timeout.</p> <code>None</code> Source code in <code>smpclient/transport/serial.py</code> <pre><code>def __init__(  # noqa: DOC301\n    self,\n    max_smp_encoded_frame_size: int = 256,\n    line_length: int = 128,\n    line_buffers: int = 2,\n    baudrate: int = 115200,\n    bytesize: int = 8,\n    parity: str = \"N\",\n    stopbits: float = 1,\n    timeout: float | None = None,\n    xonxoff: bool = False,\n    rtscts: bool = False,\n    write_timeout: float | None = None,\n    dsrdtr: bool = False,\n    inter_byte_timeout: float | None = None,\n    exclusive: bool | None = None,\n) -&gt; None:\n    \"\"\"Initialize the serial transport.\n\n    Args:\n        max_smp_encoded_frame_size: The maximum size of an encoded SMP\n            frame.  The SMP server needs to have a buffer large enough to\n            receive the encoded frame packets and to store the decoded frame.\n        line_length: The maximum SMP packet size.\n        line_buffers: The number of line buffers in the serial buffer.\n        baudrate: The baudrate of the serial connection.  OK to ignore for\n            USB CDC ACM.\n        bytesize: The number of data bits.\n        parity: The parity setting.\n        stopbits: The number of stop bits.\n        timeout: The read timeout.\n        xonxoff: Enable software flow control.\n        rtscts: Enable hardware (RTS/CTS) flow control.\n        write_timeout: The write timeout.\n        dsrdtr: Enable hardware (DSR/DTR) flow control.\n        inter_byte_timeout: The inter-byte timeout.\n        exclusive: The exclusive access timeout.\n\n    \"\"\"\n    if max_smp_encoded_frame_size &lt; line_length * line_buffers:\n        logger.error(\n            f\"{max_smp_encoded_frame_size=} is less than {line_length=} * {line_buffers=}!\"\n        )\n    elif max_smp_encoded_frame_size != line_length * line_buffers:\n        logger.warning(\n            f\"{max_smp_encoded_frame_size=} is not equal to {line_length=} * {line_buffers=}!\"\n        )\n\n    self._max_smp_encoded_frame_size: Final = max_smp_encoded_frame_size\n    self._line_length: Final = line_length\n    self._line_buffers: Final = line_buffers\n    self._conn: Final = Serial(\n        baudrate=baudrate,\n        bytesize=bytesize,\n        parity=parity,\n        stopbits=stopbits,\n        timeout=timeout,\n        xonxoff=xonxoff,\n        rtscts=rtscts,\n        write_timeout=write_timeout,\n        dsrdtr=dsrdtr,\n        inter_byte_timeout=inter_byte_timeout,\n        exclusive=exclusive,\n    )\n    self._buffer = SMPSerialTransport._ReadBuffer()\n    logger.debug(f\"Initialized {self.__class__.__name__}\")\n</code></pre>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.connect","title":"<code>connect(address: str, timeout_s: float) -&gt; None</code>  <code>async</code>","text":"<p>Connect the <code>SMPTransport</code>.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The SMP server address.</p> required <code>timeout_s</code> <code>float</code> <p>The connection timeout in seconds.</p> required Source code in <code>smpclient/transport/serial.py</code> <pre><code>@override\nasync def connect(self, address: str, timeout_s: float) -&gt; None:\n    self._conn.port = address\n    logger.debug(f\"Connecting to {self._conn.port=}\")\n    start_time: Final = time.time()\n    while time.time() - start_time &lt;= timeout_s:\n        try:\n            self._conn.open()\n            logger.debug(f\"Connected to {self._conn.port=}\")\n            return\n        except SerialException as e:\n            logger.debug(\n                f\"Failed to connect to {self._conn.port=}: {e}, \"\n                f\"retrying in {SMPSerialTransport._CONNECTION_RETRY_INTERVAL_S} seconds\"\n            )\n            await asyncio.sleep(SMPSerialTransport._CONNECTION_RETRY_INTERVAL_S)\n\n    raise TimeoutError(f\"Failed to connect to {address=}\")\n</code></pre>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.disconnect","title":"<code>disconnect() -&gt; None</code>  <code>async</code>","text":"<p>Disconnect the <code>SMPTransport</code>.</p> Source code in <code>smpclient/transport/serial.py</code> <pre><code>@override\nasync def disconnect(self) -&gt; None:\n    logger.debug(f\"Disconnecting from {self._conn.port=}\")\n    self._conn.close()\n    logger.debug(f\"Disconnected from {self._conn.port=}\")\n</code></pre>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.send","title":"<code>send(data: bytes) -&gt; None</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required Source code in <code>smpclient/transport/serial.py</code> <pre><code>@override\nasync def send(self, data: bytes) -&gt; None:\n    if len(data) &gt; self.max_unencoded_size:\n        raise ValueError(\n            f\"Data size {len(data)} exceeds maximum unencoded size {self.max_unencoded_size}\"\n        )\n    logger.debug(f\"Sending {len(data)} bytes\")\n    try:\n        for packet in smppacket.encode(data, line_length=self._line_length):\n            self._conn.write(packet)\n            logger.debug(f\"Writing encoded packet of size {len(packet)}B; {self._line_length=}\")\n\n        # fake async until I get around to replacing pyserial\n        while self._conn.out_waiting &gt; 0:\n            await asyncio.sleep(SMPSerialTransport._POLLING_INTERVAL_S)\n    except SerialException as e:\n        logger.error(f\"Failed to send {len(data)} bytes: {e}\")\n        raise SMPTransportDisconnected(\n            f\"{self.__class__.__name__} disconnected from {self._conn.port}\"\n        )\n\n    logger.debug(f\"Sent {len(data)} bytes\")\n</code></pre>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.receive","title":"<code>receive() -&gt; bytes</code>  <code>async</code>","text":"<p>Receive the decoded <code>SMPResponse</code> data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/serial.py</code> <pre><code>@override\nasync def receive(self) -&gt; bytes:\n    decoder = smppacket.decode()\n    next(decoder)\n\n    logger.debug(\"Waiting for response\")\n    while True:\n        try:\n            b = await self._readuntil()\n            decoder.send(b)\n        except StopIteration as e:\n            logger.debug(f\"Finished receiving {len(e.value)} byte response\")\n            return e.value\n        except SerialException as e:\n            logger.error(f\"Failed to receive response: {e}\")\n            raise SMPTransportDisconnected(\n                f\"{self.__class__.__name__} disconnected from {self._conn.port}\"\n            )\n</code></pre>"},{"location":"transport/serial/#smpclient.transport.serial.SMPSerialTransport.send_and_receive","title":"<code>send_and_receive(data: bytes) -&gt; bytes</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code> and receive the decoded <code>SMPResponse</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/serial.py</code> <pre><code>@override\nasync def send_and_receive(self, data: bytes) -&gt; bytes:\n    await self.send(data)\n    return await self.receive()\n</code></pre>"},{"location":"transport/transport/","title":"SMP Transport","text":"<p>Simple Management Protocol (SMP) Client Transport Protocol.</p>"},{"location":"transport/transport/#smpclient.transport.SMPTransportDisconnected","title":"<code>SMPTransportDisconnected</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when the SMP transport is disconnected.</p> Source code in <code>smpclient/transport/__init__.py</code> <pre><code>class SMPTransportDisconnected(Exception):\n    \"\"\"Raised when the SMP transport is disconnected.\"\"\"\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport","title":"<code>SMPTransport</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>smpclient/transport/__init__.py</code> <pre><code>class SMPTransport(Protocol):\n    _smp_server_transport_buffer_size: int | None = None\n    \"\"\"The SMP server transport buffer size, in 8-bit bytes.\"\"\"\n\n    async def connect(self, address: str, timeout_s: float) -&gt; None:  # pragma: no cover\n        \"\"\"Connect the `SMPTransport`.\n\n        Args:\n            address: The SMP server address.\n            timeout_s: The connection timeout in seconds.\"\"\"\n\n    async def disconnect(self) -&gt; None:  # pragma: no cover\n        \"\"\"Disconnect the `SMPTransport`.\"\"\"\n\n    async def send(self, data: bytes) -&gt; None:  # pragma: no cover\n        \"\"\"Send the encoded `SMPRequest` `data`.\n\n        Args:\n            data: The encoded `SMPRequest`.\n        \"\"\"\n\n    async def receive(self) -&gt; bytes:  # pragma: no cover\n        \"\"\"Receive the decoded `SMPResponse` data.\n\n        Returns:\n            The `SMPResponse` bytes.\n        \"\"\"\n\n    async def send_and_receive(self, data: bytes) -&gt; bytes:  # pragma: no cover\n        \"\"\"Send the encoded `SMPRequest` `data` and receive the decoded `SMPResponse`.\n\n        Args:\n            data: The encoded `SMPRequest`.\n\n        Returns:\n            The `SMPResponse` bytes.\n        \"\"\"\n\n    def initialize(self, smp_server_transport_buffer_size: int) -&gt; None:  # pragma: no cover\n        \"\"\"Initialize the `SMPTransport` with the server transport buffer size.\n\n        Args:\n            smp_server_transport_buffer_size: The SMP server transport buffer size, in 8-bit bytes.\n        \"\"\"\n        self._smp_server_transport_buffer_size = smp_server_transport_buffer_size\n\n    @property\n    def mtu(self) -&gt; int:  # pragma: no cover\n        \"\"\"The Maximum Transmission Unit (MTU) in 8-bit bytes.\"\"\"\n\n    @property\n    def max_unencoded_size(self) -&gt; int:  # pragma: no cover\n        \"\"\"The maximum size of an unencoded message that can be sent, in 8-bit bytes.\"\"\"\n\n        # There is a potential speedup in the future by taking advantage of the\n        # multiple buffers that are provided by the SMP server implementation.\n        # Generally, the idea is to send as many as buf_count messages BEFORE\n        # awaiting the response.  This will allow the SMP server to buffer the\n        # new IO while waiting for flash writes to complete.  It creates some\n        # complexity in both the client and server and it's debatable whether\n        # or not the speedup is worth the complexity.  Specifically, if there is\n        # an error in some write, then some of the writes that have already been\n        # sent out are no longer valid.  That is, the response to each\n        # concurrent write needs to be tracked very carefully!\n\n        return self._smp_server_transport_buffer_size or self.mtu\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.mtu","title":"<code>mtu: int</code>  <code>property</code>","text":"<p>The Maximum Transmission Unit (MTU) in 8-bit bytes.</p>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.max_unencoded_size","title":"<code>max_unencoded_size: int</code>  <code>property</code>","text":"<p>The maximum size of an unencoded message that can be sent, in 8-bit bytes.</p>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.connect","title":"<code>connect(address: str, timeout_s: float) -&gt; None</code>  <code>async</code>","text":"<p>Connect the <code>SMPTransport</code>.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The SMP server address.</p> required <code>timeout_s</code> <code>float</code> <p>The connection timeout in seconds.</p> required Source code in <code>smpclient/transport/__init__.py</code> <pre><code>async def connect(self, address: str, timeout_s: float) -&gt; None:  # pragma: no cover\n    \"\"\"Connect the `SMPTransport`.\n\n    Args:\n        address: The SMP server address.\n        timeout_s: The connection timeout in seconds.\"\"\"\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.disconnect","title":"<code>disconnect() -&gt; None</code>  <code>async</code>","text":"<p>Disconnect the <code>SMPTransport</code>.</p> Source code in <code>smpclient/transport/__init__.py</code> <pre><code>async def disconnect(self) -&gt; None:  # pragma: no cover\n    \"\"\"Disconnect the `SMPTransport`.\"\"\"\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.send","title":"<code>send(data: bytes) -&gt; None</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required Source code in <code>smpclient/transport/__init__.py</code> <pre><code>async def send(self, data: bytes) -&gt; None:  # pragma: no cover\n    \"\"\"Send the encoded `SMPRequest` `data`.\n\n    Args:\n        data: The encoded `SMPRequest`.\n    \"\"\"\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.receive","title":"<code>receive() -&gt; bytes</code>  <code>async</code>","text":"<p>Receive the decoded <code>SMPResponse</code> data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/__init__.py</code> <pre><code>async def receive(self) -&gt; bytes:  # pragma: no cover\n    \"\"\"Receive the decoded `SMPResponse` data.\n\n    Returns:\n        The `SMPResponse` bytes.\n    \"\"\"\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.send_and_receive","title":"<code>send_and_receive(data: bytes) -&gt; bytes</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code> and receive the decoded <code>SMPResponse</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/__init__.py</code> <pre><code>async def send_and_receive(self, data: bytes) -&gt; bytes:  # pragma: no cover\n    \"\"\"Send the encoded `SMPRequest` `data` and receive the decoded `SMPResponse`.\n\n    Args:\n        data: The encoded `SMPRequest`.\n\n    Returns:\n        The `SMPResponse` bytes.\n    \"\"\"\n</code></pre>"},{"location":"transport/transport/#smpclient.transport.SMPTransport.initialize","title":"<code>initialize(smp_server_transport_buffer_size: int) -&gt; None</code>","text":"<p>Initialize the <code>SMPTransport</code> with the server transport buffer size.</p> <p>Parameters:</p> Name Type Description Default <code>smp_server_transport_buffer_size</code> <code>int</code> <p>The SMP server transport buffer size, in 8-bit bytes.</p> required Source code in <code>smpclient/transport/__init__.py</code> <pre><code>def initialize(self, smp_server_transport_buffer_size: int) -&gt; None:  # pragma: no cover\n    \"\"\"Initialize the `SMPTransport` with the server transport buffer size.\n\n    Args:\n        smp_server_transport_buffer_size: The SMP server transport buffer size, in 8-bit bytes.\n    \"\"\"\n    self._smp_server_transport_buffer_size = smp_server_transport_buffer_size\n</code></pre>"},{"location":"transport/udp/","title":"UDP","text":"<p>A UDP SMPTransport for Network connections like Wi-Fi or Ethernet.</p>"},{"location":"transport/udp/#smpclient.transport.udp.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport","title":"<code>SMPUDPTransport</code>","text":"<p>               Bases: <code>SMPTransport</code></p> Source code in <code>smpclient/transport/udp.py</code> <pre><code>class SMPUDPTransport(SMPTransport):\n    def __init__(self, mtu: int = 1500) -&gt; None:\n        \"\"\"Initialize the SMP UDP transport.\n\n        Args:\n            mtu: The Maximum Transmission Unit (MTU) in 8-bit bytes.\n        \"\"\"\n        self._mtu = mtu\n\n        self._client: Final = UDPClient()\n\n    @override\n    async def connect(self, address: str, timeout_s: float, port: int = 1337) -&gt; None:\n        logger.debug(f\"Connecting to {address=} {port=}\")\n        await asyncio.wait_for(self._client.connect(Addr(host=address, port=port)), timeout_s)\n        logger.info(f\"Connected to {address=} {port=}\")\n\n    @override\n    async def disconnect(self) -&gt; None:\n        logger.debug(\"Disconnecting from transport\")\n        self._client.disconnect()\n\n        if not self._client._protocol.error_queue.empty():\n            logger.warning(\n                f\"{self._client._protocol.error_queue.qsize()} exceptions were uncollected before \"\n                \"disconnecting, fetching them now\"\n            )\n            while True:\n                try:\n                    logger.warning(f\"{self._client._protocol.error_queue.get_nowait()}\")\n                except asyncio.QueueEmpty:\n                    break\n\n        logger.info(\"Disconnected from transport\")\n\n    @override\n    async def send(self, data: bytes) -&gt; None:\n        if len(data) &gt; self.max_unencoded_size:\n            logger.warning(\n                \"Fragmenting UDP packets is not recommended: \"\n                f\"{len(data)=} B &gt; {self.max_unencoded_size=} B\"\n            )\n\n        logger.debug(f\"Sending {len(data)} B\")\n        for offset in range(0, len(data), self.max_unencoded_size):\n            self._client.send(data[offset : offset + self.max_unencoded_size])\n        logger.debug(f\"Sent {len(data)} B\")\n\n    @override\n    async def receive(self) -&gt; bytes:\n        logger.debug(\"Awaiting data\")\n\n        first_packet: Final = await self._client.receive()\n        logger.debug(f\"Received {len(first_packet)} B\")\n\n        header: Final = smphdr.Header.loads(first_packet[: smphdr.Header.SIZE])\n        logger.debug(f\"Received {header=}\")\n\n        message_length: Final = header.length + smphdr.Header.SIZE\n        message: Final = bytearray(first_packet)\n\n        if len(message) != message_length:\n            logger.debug(f\"Waiting for the rest of the {message_length} B response\")\n            while len(message) &lt; message_length:\n                packet = await self._client.receive()\n                logger.debug(f\"Received {len(packet)} B\")\n                message.extend(packet)\n            if len(message) &gt; message_length:\n                error: Final = (\n                    f\"Received more data than expected: {len(message)} B &gt; {message_length} B\"\n                )\n                logger.error(error)\n                raise SMPClientException(error)\n\n        logger.debug(f\"Finished receiving message of length {message_length} B\")\n        return message\n\n    @override\n    async def send_and_receive(self, data: bytes) -&gt; bytes:\n        await self.send(data)\n        return await self.receive()\n\n    @override\n    @property\n    def mtu(self) -&gt; int:\n        return self._smp_server_transport_buffer_size or self._mtu\n</code></pre>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.mtu","title":"<code>mtu: int</code>  <code>property</code>","text":"<p>The Maximum Transmission Unit (MTU) in 8-bit bytes.</p>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.__init__","title":"<code>__init__(mtu: int = 1500) -&gt; None</code>","text":"<p>Initialize the SMP UDP transport.</p> <p>Parameters:</p> Name Type Description Default <code>mtu</code> <code>int</code> <p>The Maximum Transmission Unit (MTU) in 8-bit bytes.</p> <code>1500</code> Source code in <code>smpclient/transport/udp.py</code> <pre><code>def __init__(self, mtu: int = 1500) -&gt; None:\n    \"\"\"Initialize the SMP UDP transport.\n\n    Args:\n        mtu: The Maximum Transmission Unit (MTU) in 8-bit bytes.\n    \"\"\"\n    self._mtu = mtu\n\n    self._client: Final = UDPClient()\n</code></pre>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.connect","title":"<code>connect(address: str, timeout_s: float, port: int = 1337) -&gt; None</code>  <code>async</code>","text":"<p>Connect the <code>SMPTransport</code>.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>The SMP server address.</p> required <code>timeout_s</code> <code>float</code> <p>The connection timeout in seconds.</p> required Source code in <code>smpclient/transport/udp.py</code> <pre><code>@override\nasync def connect(self, address: str, timeout_s: float, port: int = 1337) -&gt; None:\n    logger.debug(f\"Connecting to {address=} {port=}\")\n    await asyncio.wait_for(self._client.connect(Addr(host=address, port=port)), timeout_s)\n    logger.info(f\"Connected to {address=} {port=}\")\n</code></pre>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.disconnect","title":"<code>disconnect() -&gt; None</code>  <code>async</code>","text":"<p>Disconnect the <code>SMPTransport</code>.</p> Source code in <code>smpclient/transport/udp.py</code> <pre><code>@override\nasync def disconnect(self) -&gt; None:\n    logger.debug(\"Disconnecting from transport\")\n    self._client.disconnect()\n\n    if not self._client._protocol.error_queue.empty():\n        logger.warning(\n            f\"{self._client._protocol.error_queue.qsize()} exceptions were uncollected before \"\n            \"disconnecting, fetching them now\"\n        )\n        while True:\n            try:\n                logger.warning(f\"{self._client._protocol.error_queue.get_nowait()}\")\n            except asyncio.QueueEmpty:\n                break\n\n    logger.info(\"Disconnected from transport\")\n</code></pre>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.send","title":"<code>send(data: bytes) -&gt; None</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required Source code in <code>smpclient/transport/udp.py</code> <pre><code>@override\nasync def send(self, data: bytes) -&gt; None:\n    if len(data) &gt; self.max_unencoded_size:\n        logger.warning(\n            \"Fragmenting UDP packets is not recommended: \"\n            f\"{len(data)=} B &gt; {self.max_unencoded_size=} B\"\n        )\n\n    logger.debug(f\"Sending {len(data)} B\")\n    for offset in range(0, len(data), self.max_unencoded_size):\n        self._client.send(data[offset : offset + self.max_unencoded_size])\n    logger.debug(f\"Sent {len(data)} B\")\n</code></pre>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.receive","title":"<code>receive() -&gt; bytes</code>  <code>async</code>","text":"<p>Receive the decoded <code>SMPResponse</code> data.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/udp.py</code> <pre><code>@override\nasync def receive(self) -&gt; bytes:\n    logger.debug(\"Awaiting data\")\n\n    first_packet: Final = await self._client.receive()\n    logger.debug(f\"Received {len(first_packet)} B\")\n\n    header: Final = smphdr.Header.loads(first_packet[: smphdr.Header.SIZE])\n    logger.debug(f\"Received {header=}\")\n\n    message_length: Final = header.length + smphdr.Header.SIZE\n    message: Final = bytearray(first_packet)\n\n    if len(message) != message_length:\n        logger.debug(f\"Waiting for the rest of the {message_length} B response\")\n        while len(message) &lt; message_length:\n            packet = await self._client.receive()\n            logger.debug(f\"Received {len(packet)} B\")\n            message.extend(packet)\n        if len(message) &gt; message_length:\n            error: Final = (\n                f\"Received more data than expected: {len(message)} B &gt; {message_length} B\"\n            )\n            logger.error(error)\n            raise SMPClientException(error)\n\n    logger.debug(f\"Finished receiving message of length {message_length} B\")\n    return message\n</code></pre>"},{"location":"transport/udp/#smpclient.transport.udp.SMPUDPTransport.send_and_receive","title":"<code>send_and_receive(data: bytes) -&gt; bytes</code>  <code>async</code>","text":"<p>Send the encoded <code>SMPRequest</code> <code>data</code> and receive the decoded <code>SMPResponse</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>The encoded <code>SMPRequest</code>.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>The <code>SMPResponse</code> bytes.</p> Source code in <code>smpclient/transport/udp.py</code> <pre><code>@override\nasync def send_and_receive(self, data: bytes) -&gt; bytes:\n    await self.send(data)\n    return await self.receive()\n</code></pre>"},{"location":"user/intercreate/","title":"Intercreate","text":"<p>Refer to the smp Intercreate documentation for a complete description of each Request and Response.</p>"},{"location":"user/intercreate/#smpclient.requests.user.intercreate.ImageUploadWrite","title":"<code>ImageUploadWrite</code>","text":"<p>               Bases: <code>ImageUploadWriteRequest</code>, <code>_GroupBase</code></p> <p>Upload an image to an application-defined location like a secondary MCU.</p> <p>Parameters:</p> Name Type Description Default <code>off</code> <code>int</code> required <code>image</code> <code>int | None</code> required <code>len</code> <code>int | None</code> required <code>sha</code> <code>bytes | None</code> required Source code in <code>smpclient/requests/user/intercreate.py</code> <pre><code>class ImageUploadWrite(smpic.ImageUploadWriteRequest, _GroupBase):\n    \"\"\"Upload an image to an application-defined location like a secondary MCU.\n\n    Args:\n        off (int): \n        image (int | None): \n        len (int | None): \n        sha (bytes | None): \n\n    \"\"\"\n    _Response = smpic.ImageUploadWriteResponse\n    _Response = smpic.ImageUploadWriteResponse\n</code></pre>"}]}